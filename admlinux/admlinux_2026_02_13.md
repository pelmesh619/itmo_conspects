## Лекция 2. Файлы и права доступа

В Linux и других Unix-подобных системах все объекты являются файловыми дескрипторами, то есть все действия совершаются через универсальный интерфейс

Файловый дескриптор - это идентификатор, за которым закреплен определенный поток ввода и вывода. Через файловые дескрипторы в Linux можно работать:

* с устройствами
* с процессами
* с файлами и каталогами в памяти хранилища
* и с другими объектами

Получаем единый набор операций с файловым дескриптором: открытие, чтение, запись и закрытие

Всего можно выделить 7 типов файлов:

* Регулярный файл

    Регулярный файл - это файл в обычном его понимании, то есть именованная область памяти хранилища, которая структурирована иерархически

    По умолчанию, Linux рекомендует использовать файловую систему ext4, которая использует индексные дескрипторы. Поэтому на диске файл представлен индексным дескриптором в начале блочного устройства

    ![Формат индексного дескриптора](./images/admlinux_ext4_inode.png)

    Когда файл создается, в таблице индексных дескрипторов появляется индексный дескриптор файла. При записи операционная система выделяет новые блоки на блочном устройстве и добавляет ссылки на эти блоки в индексном дескрипторе, а при удалении удаляется индексный дескриптор

    При этом файл в Linux не хранит свое имя - это ответственность каталога

* Каталог

    Каталог - это таблица, содержащая имя файла, его индексный дескриптор и опционально другие данные. В разных операционных системах применяет разная терминология, в Windows применяется офисный термин "папка" (folder), а в Linux каталоги называются директориями (directory)

    Каталоги позволяют задавать иерархическую структуру на блочном устройстве. Так как это таблица, где ключ - это имя файла или каталога, нельзя создать в одном каталоге файл и каталог с одним и тем же именем, в отличие от Windows

    ![Формат каталога](./images/admlinux_directory.png)

    Linux позволяет создавать не просто файлы в каталоге, а жесткие ссылки на файлы в каталоге. При создании жесткой ссылки:

    ```bash
    ln исходный_файл новый_файл
    ```

    Файлы `исходный_файл` и `новый_файл` будут иметь те же содержимое и индексный дескриптор, однако храниться в разных каталогах одновременно. Удаление одного из них не приведет к потери ссылок на блоки, где хранятся данные. Чтобы

    Жесткие ссылки нельзя создавать:

    * на каталоги, так как в этом случае может получиться циклическая зависимость, из-за чего рекурсивные алгоритмы для работы с файловым деревом ломаются
    * в каталогах, находящихся в разных файловых системах (то есть в разных разделах или устройствах), так как они имеют разные таблицы с индексными дескрипторами или же не иметь вовсе таковой (как, например, в системе FAT)

* Символическая (или мягкая) ссылка

    Символическая ссылка (symlink или softlink) - это еще один тип файла, который внутри хранит путь до другого файла в файловой системе. При обращении путь к ссылке подменяется операционной системой на содержащийся внутри путь файла, что позволяет обойти ограничения, связанные с жесткой ссылкой

    Символическая ссылка может быть сломанной или битой, если она указывает на файл или каталог, который не существует

    Символическую ссылку можно сделать с помощью команды `ln`:

    ```bash
    ln -s исходный_файл имя_ссылки
    ```

* Файлы-дырки

    Файлы-дырки (filehole) не хранят ничего на жестком диске компьютера непосредственно, однако с помощью них осуществляется доступ к подключенным устройствам и объектам операционном системы

    Файлами-дырками могут быть:

    * сокеты - объекты для сетевой коммуникации компьютеров
    * именованные каналы (также пайп) - очереди символов для передачи данных между процессами
    * блочные устройства - устройства, в которых данные хранятся блоками, например жесткие диски, флешки, DVD и так далее
    * символьные устройства - такие устройства, как мышь, консоль и другие

    Особое место занимает каталог `/dev/`. В нем содержаться все устройства, в том числе виртуальные, к которым операционная система имеет доступ. Есть два типа организации этого каталога:

    * Статическая - в этом случае список подключаемых устройств известен заранее, поэтому ядро имеет все нужны драйвера, а системный администратор вручную заводит файловый дескриптор в `/dev/` для каждого устройства
    * Динамическая - в этом случае ядро автоматически загружает необходимый драйвер для устройства и создает файловый дескриптор, по сути аналог Plug-and-Play от Microsoft

    Так `/dev/` содержит:

    * `/dev/console` - консоль для вывода системных сообщений при запуске и завершении системы
    * `/dev/tty` - консоль текущего процесса
    * `/dev/tty1`, `/dev/tty2`, ... - виртуальные консоли, доступные через Ctrl+Alt+F1 и так далее
    * `/dev/sda` (аналогично `/dev/sd+буква`) - жесткий диск, подключенный через SATA
    * `/dev/nvme0n1` (аналогично `/dev/nvme0n+цифра`) - твердотельный накопитель с технологией NVMe, в данном случае `nvme0` - это номер PCIe-шины
    * `/dev/nvme0n1p1` - первый раздел на этом накопителе

    * `/dev/fb0` - буфер кадра в видеопамяти графического процессора
    * `/dev/mouse0` - мышь
    * `/dev/null` - канал, в который можно перевести символьный поток (например, вывод процесса), чтобы уничтожить его
    * `/dev/zero` - поток, который генерирует нули
    * `/dev/random` - поток, который генерирует рандомные символы
    * `/dev/full` - поток, который возвращает ошибку "Недостаточно места"

    Каждый процесс (кроме демонов) при создании получает 3 символьных файловых дескриптора: стандартный поток ввода с номером `0`, стандартный поток вывода с номером `1` и стандартный поток ошибок с номером `2`. На них есть символические ссылки `/dev/stdin`, `/dev/stdout` и `/dev/stderr`

---

Используя команду `ls -l`, можно посмотреть на информацию о файлах в каталоге, например:

```bash
crw-r--r--   1 root      root       10,   235 Feb 13 17:59 autofs
drwxr-xr-x   2 root      root             180 Feb 13 17:59 block
crw-rw----   1 root      disk       10,   234 Feb 13 17:59 btrfs-control
drwxr-xr-x   3 root      root              60 Feb 13 17:59 bus
drwxr-xr-x   2 root      root            4920 Feb 13 17:59 char
crw-------   1 root      root        5,     1 Feb 13 17:59 console
lrwxrwxrwx   1 root      root              11 Feb 13 17:59 core -> /proc/kcore
drwxr-xr-x  14 root      root             280 Feb 13 17:59 cpu
crw-------   1 root      root       10,   259 Feb 13 17:59 cpu_dma_latency
```

Первый столбец обозначает тип файла и его модификаторы доступа. Первая буква - это тип файла, так:

* `-` - это регулярный файл
* `d` - это директория (от directory)
* `l` - это символическая ссылка (от link)
* `s` - это сокет (от socket)
* `b` - это блочное устройство (от block)
* `c` - это символьное устройство (от character)
* `p` - это именованный канал (от pipe)

Следующие 9 букв задают права доступа для файла. В Linux действует [ролевая модель доступа](https://pelmesh619.github.io/itmo_conspects/databases/databases_superconspect.html#role_access_control), поэтому есть такие понятия:

* Пользователь файла (User) - его непосредственный владелец, тот, кто создал файл
* Группа владельца файла (Group) - другие пользователи, входящие в ту же группу
* Все остальные пользователи в системе (Other)

Так модификаторы доступа делятся на три тройки букв, каждая тройка из которых показывает права для определенной выборки пользователей

* Буква `r` - право на чтение файла или чтение имен файлов внутри каталога
* Буква `w` - право на запись в файл
* Буква `x` - право на исполнение файла или чтение свойств файлов внутри каталога

Так `-rwxr-xr-x` означает регулярный файл, читать и исполнять который могут все, а записывать только владелец

Помимо этих 9 модификаторов есть еще 3 скрытых:

* SUID (Set User ID upon execution) - пользователи, которые могут запустить выполнение файл, запускают его с правами владельца. Для каталогов этот флаг ничего не делает. В `ls -l` обозначается как `--s------` (если установлен `x` для владельца) или `--S------`
* SGID (Set Group ID upon execution) - пользователи, которые могут запустить выполнение файл, запускают его с правами группы владельца. Для каталог этот флаг означает то, что новые файлы создают с той же группой, которая привязана к каталогу, а не основной группой для пользователя. В `ls -l` обозначается как `-----s---` (если установлен `x` для пользователей группы) или `-----S---`
* T-бит или Sticky Bit - файлы в каталоге с таким флагом может удалить или переименовать только владелец файла. В `ls -l` обозначается как `--------t` (если установлен `x` для остальных пользователей) или `--------T`

Права можно установить для файла с помощью команды `chmod` (от change mode):

```bash
chmod права файл
```

Права указываются:

* В двоичном формате, так, `101101000` означает `r-xr-x---`, при этом 10-ый бит предназначен для T-бита, 11-ый бит - для SGID, 12-ый бит - для SUID
* В восьмеричном формате, например, `754` означает `rwxr-xr--`, `2555` означает `r-xr-sr-x`
* В символьном формате, то есть `rwxr-xr--`
* С указанием выборки пользователей. Например:

    * `chmod u+x file` добавляет право на исполнение файла владельцу
    * `chmod u+w,o-w file` добавляет право на запись владельцу и убирает право на запись пользователям вне группы
    * `chmod g+s file` добавляет флаг SUID
    * `chmod o+s file` добавляет флаг Sticky Bit
    * `chmod g=rx file` устанавливает права на чтение и запись группе вместо тех права, что были до этого

Второй столбец - это число жесткий ссылок на файл

Третий столбец из вывода `ls -l` указывает на владельца файла, а четвертый - на группу владельца (так как пользователь может состоять в нескольких группах). Сменить владельца можно с помощью команды `chown` (от change owner):

```bash
# меняет владельца на pelmeshke
chown pelmeshke /var/log/mylogs/app.log

# меняет владельца на pelmeshke и группу на supercoolusers
chown pelmeshke:supercoolusers /var/log/mylogs/app.log

# меняет владельца на pelmeshke рекурсивно 
# для всех файлов и каталогов в /var/log/mylogs
chown -R pelmeshke /var/log/mylogs/
```

Для смены группы также есть команда `chgrp` (от change group):

```bash
# меняет группу на supercoolusers
chown supercoolusers /var/log/mylogs/app.log
```
