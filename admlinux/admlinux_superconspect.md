# <a name="%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-%D0%BE%D1%81-linux"></a> Администрирование в ОС Linux


* [Администрирование в ОС Linux](#%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-%D0%BE%D1%81-linux)
  * [Лекция 1. Введение в Linux](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-1.-%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-linux)
  * [Лекция 2. Файлы и права доступа](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-2.-%D1%84%D0%B0%D0%B9%D0%BB%D1%8B-%D0%B8-%D0%BF%D1%80%D0%B0%D0%B2%D0%B0-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0)
  * [Лекция 3. Файловые системы](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-3.-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B)



> **Операционная система** - это базовое системное программное обеспечение, управляющее работой вычислительного узла и реализующее универсальный интерфейс между аппаратным обеспечением, программным обеспечением и пользователем

Возможности по изменению аппаратного обеспечения часто ограничены, поэтому на практике стремятся извлечь максимальную производительность и гибкость за счёт программного обеспечения и грамотного администрирования ОС

Курс разделен на несколько блоков:

1. Работа с файлами
2. Файловые системы
3. Процессы и управление ресурсами
4. Межпроцессорное взаимодействие
5. Загрузка операционной системы
6. Механизмы контейнеризации
7. Управление пользовательским ПО
8. Графические среды

## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-1.-%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-linux"></a> Лекция 1. Введение в Linux

> **Linux** (в части случаев GNU/Linux) - это семейство открытых и свободных Unix-подобных операционных систем на базе ядра Linux, включающих набор утилит и программ проекта GNU, а также другие системные и прикладные компоненты

Linux начал своё развитие в 1991 году, когда Линус Торвальдс, будучи студентом Хельсинкского университета, опубликовал первую версию ядра Linux как учебный и исследовательский проект

Со временем вокруг ядра Linux сформировалось большое сообщество разработчиков, а сам Linux стал использоваться в серверах, настольных системах, мобильных и других устройствах

Разделяют бесплатное ПО, открытое ПО и свободное ПО

Бесплатное ПО (Freeware) - программное обеспечение, распространяющееся бесплатно конечному пользователю в виде исполняемых файлов

Открытое ПО (Open-Source Software) - программное обеспечение с открытым исходным кодом, чаще всего распространяющимся по [разрешительной лицензии](https://pelmesh619.github.io/itmo_conspects/devtools/devtools_superconspect.html#%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D0%B5-%D0%BF%D0%BE)

Свободное ПО (Free and Open-Source Software, FOSS) - открытое программное обеспечение, лицензия которого заставляет авторов производных от него работ лицензировать их под той же [свободной лицензией](https://pelmesh619.github.io/itmo_conspects/devtools/devtools_superconspect.html#%D1%81%D0%B2%D0%BE%D0%B1%D0%BE%D0%B4%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE)

Linux является свободным программным обеспечением и распространяется под лицензией **GNU General Public License 2.0**. Это означает, что операционная система Linux гарантирует пользователю 4 свободы, сформулированные Ричардом Столлманом, основателем проекта GNU:

* Свобода запускать программу в любых целях (свобода 0).
* Свобода изучения работы программы и адаптация её к вашим нуждам (свобода 1). Доступ к исходным текстам является необходимым условием.
* Свобода распространять копии, так что вы можете помочь вашему товарищу (свобода 2).
* Свобода улучшать программу и публиковать ваши улучшения, так что всё общество выиграет от этого (свобода 3). Доступ к исходным текстам является необходимым условием.

Лицензия GNU General Public License 2.0 накладывает обязательство на то, что производные работы также должны распространяться на условиях этой лицензии

Linux включает набор утилит и программ GNU, такие как Bash или GNU Compiler Collection, которые тоже являются свободным ПО

Linux распространяется не только в виде ядра, но и в виде *дистрибутивов* - готовых комплектов программного обеспечения, включающих ядро, системные утилиты, менеджер пакетов, установщик и часто графическую среду. Сейчас популярные дистрибутивы - это Debian, Ubuntu, Fedora, Arch Linux и другие

Дистрибутивы Linux бесплатные, но не все. Так, например, Red Hat Enterprise Linux распространяется по платной модели, имея открытый код, но за плату предлагается расширенная корпоративная поддержка и сервис

---

Ключевые отличия свободного ПО и проприетарного ПО заключаются:

* *В доступу к исходному коду*

* *В модели поддержки*. В свободном ПО поддержка часто осуществляется сообществом или сторонними компаниями, а в проприетарном ПО - официальным производителем

* *В поиске и исправлении уязвимостей*. Открытый код позволяет независимый аудит безопасности, тогда как при использовании проприетарного ПО пользователь вынужден доверять разработчику

* *В гибкости и кастомизации*. Свободное ПО можно модифицировать под конкретные нужды, проприетарное, как правило, нет

---

Долгое время наиболее популярной настольной операционной системой остаётся Microsoft Windows. Рассмотрим ключевые концептуальные отличия Linux от Windows:

* Работа с файлами

    В Linux все объекты, в том числе файлы, сетевые сокеты, устройства, каналы, - это файловые дескрипторы, поэтому взаимодействие с ними осуществляется через файловую систему

    В Windows пользователь чаще взаимодействует с действиями и приложениями, а не с абстрактными объектами файловой системы

* Иерархия файловой системы

    Linux использует единую иерархию каталогов, начинающуюся с корня `/`, тогда как в Windows используется несколько корней: диски `C:`, `D:` и так далее

* Права доступа

    В Linux строгая модель прав доступа: владелец, группа и остальные; В Windows используется модель NTFS-разрешений, менее прозрачная для пользователя.

* Обновления и установка ПО

    В Linux программное обеспечение обычно устанавливается из централизованных репозиториев через менеджеры пакетов. В Windows чаще используются отдельные установщики для каждого приложения

## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-2.-%D1%84%D0%B0%D0%B9%D0%BB%D1%8B-%D0%B8-%D0%BF%D1%80%D0%B0%D0%B2%D0%B0-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0"></a> Лекция 2. Файлы и права доступа

В Linux и других Unix-подобных системах все объекты являются файловыми дескрипторами, то есть все действия совершаются через универсальный интерфейс

Файловый дескриптор - это идентификатор, за которым закреплен определенный поток ввода и вывода. Через файловые дескрипторы в Linux можно работать:

* с устройствами
* с процессами
* с файлами и каталогами в памяти хранилища
* и с другими объектами

Получаем единый набор операций с файловым дескриптором: открытие, чтение, запись и закрытие

Всего можно выделить 7 типов файлов:

* Регулярный файл

    Регулярный файл - это файл в обычном его понимании, то есть именованная область памяти хранилища, которая структурирована иерархически

    По умолчанию, Linux рекомендует использовать файловую систему ext4, которая использует индексные дескрипторы. Поэтому на диске файл представлен индексным дескриптором в начале блочного устройства

    ![Формат индексного дескриптора](./images/admlinux_ext4_inode.png)

    Когда файл создается, в таблице индексных дескрипторов появляется индексный дескриптор файла. При записи операционная система выделяет новые блоки на блочном устройстве и добавляет ссылки на эти блоки в индексном дескрипторе, а при удалении удаляется индексный дескриптор

    При этом файл в Linux не хранит свое имя - это ответственность каталога

* Каталог

    Каталог - это таблица, содержащая имя файла, его индексный дескриптор и опционально другие данные. В разных операционных системах применяет разная терминология, в Windows применяется офисный термин "папка" (folder), а в Linux каталоги называются директориями (directory)

    Каталоги позволяют задавать иерархическую структуру на блочном устройстве. Так как это таблица, где ключ - это имя файла или каталога, нельзя создать в одном каталоге файл и каталог с одним и тем же именем, в отличие от Windows

    ![Формат каталога](./images/admlinux_directory.png)

    Linux позволяет создавать не просто файлы в каталоге, а жесткие ссылки на файлы в каталоге. При создании жесткой ссылки:

    ```bash
    ln исходный_файл новый_файл
    ```

    Файлы `исходный_файл` и `новый_файл` будут иметь те же содержимое и индексный дескриптор, однако храниться в разных каталогах одновременно. Удаление одного из них не приведет к потери ссылок на блоки, где хранятся данные. Чтобы удалился сам индексный дескриптор, нужно, что бы счетчик жестких ссылок достиг нуля

    Жесткие ссылки нельзя создавать:

    * на каталоги, так как в этом случае может получиться циклическая зависимость, из-за чего рекурсивные алгоритмы для работы с файловым деревом ломаются
    * в каталогах, находящихся в разных файловых системах (то есть в разных разделах или устройствах), так как они имеют разные таблицы с индексными дескрипторами или же не иметь вовсе таковой (как, например, в системе FAT)

* Символическая (или мягкая) ссылка

    Символическая ссылка (symlink или softlink) - это еще один тип файла, который внутри хранит путь до другого файла в файловой системе. При обращении путь к ссылке подменяется операционной системой на содержащийся внутри путь файла, что позволяет обойти ограничения, связанные с жесткой ссылкой

    Символическая ссылка может быть сломанной или битой, если она указывает на файл или каталог, который не существует

    Символическую ссылку можно сделать с помощью команды `ln`:

    ```bash
    ln -s исходный_файл имя_ссылки
    ```

* Файлы-дырки

    Файлы-дырки (filehole) не хранят ничего на жестком диске компьютера непосредственно, однако с помощью них осуществляется доступ к подключенным устройствам и объектам операционном системы

    Файлами-дырками могут быть:

    * сокеты - объекты для сетевой коммуникации компьютеров
    * именованные каналы (также пайп) - очереди символов для передачи данных между процессами
    * блочные устройства - устройства, в которых данные хранятся блоками, например жесткие диски, флешки, DVD и так далее
    * символьные устройства - такие устройства, как мышь, консоль и другие

    Особое место занимает каталог `/dev/`. В нем содержатся все устройства, в том числе виртуальные, к которым операционная система имеет доступ. Есть два типа организации этого каталога:

    * Статическая - в этом случае список подключаемых устройств известен заранее, поэтому ядро имеет все нужны драйвера, а системный администратор вручную заводит файловый дескриптор в `/dev/` для каждого устройства
    * Динамическая - в этом случае ядро автоматически загружает необходимый драйвер для устройства и создает файловый дескриптор, по сути аналог Plug-and-Play от Microsoft

    Так `/dev/` содержит:

    * `/dev/console` - консоль для вывода системных сообщений при запуске и завершении системы
    * `/dev/tty` - консоль текущего процесса
    * `/dev/tty1`, `/dev/tty2`, ... - виртуальные консоли, доступные через Ctrl+Alt+F1 и так далее
    * `/dev/sda` (аналогично `/dev/sd+буква`) - жесткий диск, подключенный через SATA
    * `/dev/nvme0n1` (аналогично `/dev/nvme0n+цифра`) - твердотельный накопитель с технологией NVMe, в данном случае `nvme0` - это номер PCIe-шины
    * `/dev/nvme0n1p1` - первый раздел на этом накопителе

    * `/dev/fb0` - буфер кадра в видеопамяти графического процессора
    * `/dev/mouse0` - мышь
    * `/dev/null` - канал, в который можно перевести символьный поток (например, вывод процесса), чтобы уничтожить его
    * `/dev/zero` - поток, который генерирует нули
    * `/dev/random` - поток, который генерирует рандомные символы
    * `/dev/full` - поток, который возвращает ошибку "Недостаточно места"

    Каждый процесс (кроме демонов) при создании получает 3 символьных файловых дескриптора: стандартный поток ввода с номером `0`, стандартный поток вывода с номером `1` и стандартный поток ошибок с номером `2`. На них есть символические ссылки `/dev/stdin`, `/dev/stdout` и `/dev/stderr`

---

Используя команду `ls -l`, можно посмотреть на информацию о файлах в каталоге, например:

```bash
crw-r--r--   1 root      root       10,   235 Feb 13 17:59 autofs
drwxr-xr-x   2 root      root             180 Feb 13 17:59 block
crw-rw----   1 root      disk       10,   234 Feb 13 17:59 btrfs-control
drwxr-xr-x   3 root      root              60 Feb 13 17:59 bus
drwxr-xr-x   2 root      root            4920 Feb 13 17:59 char
crw-------   1 root      root        5,     1 Feb 13 17:59 console
lrwxrwxrwx   1 root      root              11 Feb 13 17:59 core -> /proc/kcore
drwxr-xr-x  14 root      root             280 Feb 13 17:59 cpu
crw-------   1 root      root       10,   259 Feb 13 17:59 cpu_dma_latency
```

Первый столбец обозначает тип файла и его модификаторы доступа. Первая буква - это тип файла, так:

* `-` - это регулярный файл
* `d` - это директория (от directory)
* `l` - это символическая ссылка (от link)
* `s` - это сокет (от socket)
* `b` - это блочное устройство (от block)
* `c` - это символьное устройство (от character)
* `p` - это именованный канал (от pipe)

Следующие 9 букв задают права доступа для файла. В Linux действует [ролевая модель доступа](https://pelmesh619.github.io/itmo_conspects/databases/databases_superconspect.html#role_access_control), поэтому есть такие понятия:

* Пользователь файла (User) - его непосредственный владелец, тот, кто создал файл
* Группа владельца файла (Group) - другие пользователи, входящие в ту же группу
* Все остальные пользователи в системе (Other)

Так модификаторы доступа делятся на три тройки букв, каждая тройка из которых показывает права для определенной выборки пользователей

* Буква `r` - право на чтение файла или чтение имен файлов внутри каталога
* Буква `w` - право на запись в файл
* Буква `x` - право на исполнение файла или чтение свойств файлов внутри каталога

Так `-rwxr-xr-x` означает регулярный файл, читать и исполнять который могут все, а записывать только владелец

Помимо этих 9 модификаторов есть еще 3 скрытых:

* SUID (Set User ID upon execution) - пользователи, которые могут запустить выполнение файл, запускают его с правами владельца. Для каталогов этот флаг ничего не делает. В `ls -l` обозначается как `--s------` (если установлен `x` для владельца) или `--S------`
* SGID (Set Group ID upon execution) - пользователи, которые могут запустить выполнение файл, запускают его с правами группы владельца. Для каталог этот флаг означает то, что новые файлы создают с той же группой, которая привязана к каталогу, а не основной группой для пользователя. В `ls -l` обозначается как `-----s---` (если установлен `x` для пользователей группы) или `-----S---`
* T-бит или Sticky Bit - файлы в каталоге с таким флагом может удалить или переименовать только владелец файла. В `ls -l` обозначается как `--------t` (если установлен `x` для остальных пользователей) или `--------T`

Права можно установить для файла с помощью команды `chmod` (от change mode):

```bash
chmod права файл
```

Права указываются:

* В двоичном формате, так, `101101000` означает `r-xr-x---`, при этом 10-ый бит предназначен для T-бита, 11-ый бит - для SGID, 12-ый бит - для SUID
* В восьмеричном формате, например, `754` означает `rwxr-xr--`, `2555` означает `r-xr-sr-x`
* В символьном формате, то есть `rwxr-xr--`
* С указанием выборки пользователей. Например:

    * `chmod u+x file` добавляет право на исполнение файла владельцу
    * `chmod u+w,o-w file` добавляет право на запись владельцу и убирает право на запись пользователям вне группы
    * `chmod g+s file` добавляет флаг SUID
    * `chmod o+s file` добавляет флаг Sticky Bit
    * `chmod g=rx file` устанавливает права на чтение и запись группе вместо тех права, что были до этого

Второй столбец - это число жесткий ссылок на файл

Третий столбец из вывода `ls -l` указывает на владельца файла, а четвертый - на группу владельца (так как пользователь может состоять в нескольких группах). Сменить владельца можно с помощью команды `chown` (от change owner):

```bash
# меняет владельца на pelmeshke
chown pelmeshke /var/log/mylogs/app.log

# меняет владельца на pelmeshke и группу на supercoolusers
chown pelmeshke:supercoolusers /var/log/mylogs/app.log

# меняет владельца на pelmeshke рекурсивно 
# для всех файлов и каталогов в /var/log/mylogs
chown -R pelmeshke /var/log/mylogs/
```

Для смены группы также есть команда `chgrp` (от change group):

```bash
# меняет группу на supercoolusers
chgrp supercoolusers /var/log/mylogs/app.log
```

## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-3.-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B"></a> Лекция 3. Файловые системы

Файловая система - это способ организации информации на носителе данных

Файловая система выполняет такие функции:

* Организацию хранения данных
* Управление доступом
* Учет и распределение дискового пространства
* Обеспечение целостности
* Поддержка операций ввода-вывода

Файловая система является посредником в общении между пользователем, использующим ОС, и жестким диском

Позднее число файловых систем стало настолько большим, что в архитектуре операционных систем стала появляется виртуальная файловая система - стандартизованный интерфейс между системными вызовами и конкретной файловой системой

![Взаимодействие с хранилищами](./images/admlinux_file_system.png)

---

Файловые системы могут использовать множество методов организации:

1. Линейное размещение
2. Связный список
3. Таблица аллокаций файлов
4. Индексные дескрипторы

Подробнее об этом описано в курсе ["Операционные системы"](https://pelmesh619.github.io/itmo_conspects/opersys/opersys_superconspect.html#-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-14-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0)

Современные операционные системы используют файловые системы с индексными дескрипторами для дисков, на которых установлена система. Так, Windows использует NTFS (New Technology File System), а для Linux рекомендуется ext4 (от Fourth Extended, Четвертая расширенная файловая система)

В файловой системе ext4 в начале блочного устройства есть участок с названием суперблок (Superblock). Суперблок - это структура, состоящая из данных, которые определяют организацию данных:

| Поле                       | Тип данных  | Назначение                                  |
| -------------------------- | ----------- | ------------------------------------------- |
| `s_inodes_count`           | `__le32`    | Общее количество индексных дескрипторов     |
| `s_blocks_count_lo`        | `__le32`    | Общее количество блоков (младшие 32 бита)   |
| `s_r_blocks_count_lo`      | `__le32`    | Зарезервированные блоки (младшие 32 бита)   |
| `s_free_blocks_count_lo`   | `__le32`    | Свободные блоки (младшие 32 бита)           |
| `s_free_inodes_count`      | `__le32`    | Количество свободных индексных дескрипторов |
| `s_first_data_block`       | `__le32`    | Первый блок данных                          |
| `s_log_block_size`         | `__le32`    | Логарифм размера блока в килобайтах по основанию 2       |
| `s_log_cluster_size`       | `__le32`    | Логарифм размера кластера в килобайтах по основанию 2    |
| `s_blocks_per_group`       | `__le32`    | Блоков в группе                             |
| `s_clusters_per_group`     | `__le32`    | Кластеров в группе                          |
| `s_inodes_per_group`       | `__le32`    | Индексных дескрипторов в группе             |
| `s_mtime`                  | `__le32`    | Время последнего монтирования               |
| `s_wtime`                  | `__le32`    | Время последней записи                      |
| `s_mnt_count`              | `__le16`    | Счётчик монтирований после проверки диска   |
| `s_max_mnt_count`          | `__le16`    | Максимальное число монтирований, после который нужна проверка диска |
| `s_magic`                  | `__le16`    | Магическое число, для ext4 - это `0xEF53`   |
| `s_state`                  | `__le16`    | Состояние файловой системы                  |
| `s_errors`                 | `__le16`    | Поведение при ошибках                       |
| `s_minor_rev_level`        | `__le16`    | Минорная версия                             |
| `s_lastcheck`              | `__le32`    | Время последней проверки                    |
| `s_checkinterval`          | `__le32`    | Интервал проверки                           |
| `s_creator_os`             | `__le32`    | Операционная система, создавшая раздел (Linux - это `0x0000`, FreeBSD - это `0x0003`) |
| `s_first_ino`              | `__le32`    | Первый незарезервированный индексный дескриптор |
| `s_inode_size`             | `__le16`    | Размер индексного дескриптора (обычно 256 байт) |
| `s_block_group_nr`         | `__le16`    | Номер группы (для копии суперблока)         |
| `s_uuid`                   | `__u8[16]`  | UUID файловой системы                       |
| `s_volume_name`            | `char[16]`  | Имя тома                                    |

... и много других

Здесь `__le16`, `__le32` - беззнаковые целые числа, записанные в Little-endian, размером 16 бит и 32 бита соответственно, `__u8[16]` - 16-байтный массив беззнаковый 8-битных чисел, а `char[16]` - символьная последовательность

> Источник: <https://docs.kernel.org/next/filesystems/ext4/super.html>

Со временем появилась идея размещать блоки больших файлов рядом друг с другом, чтобы уменьшать движение читающей головки жесткого диска по секторам

Для решения этого появились группы блоков. Группы содержат свои битовые карты, таблицы индексных дескрипторов и блоки данных

Первая группа под индексом 0 хранит суперблок и таблицу дескрипторов блочных групп (Block Group Descriptors) - структуры с данными полями:

| Поле                      | Тип данных | Назначение                                  |
| ------------------------- | ---------- | ------------------------------------------- |
| `bg_block_bitmap_lo`      | `__le32`   | Номер блока битовой карты блоков (младшие 32 бита) |
| `bg_inode_bitmap_lo`      | `__le32`   | Номер блока битовой карты дескрипторов (младшие 32 бита)  |
| `bg_inode_table_lo`       | `__le32`   | Первый блок таблицы индексных дескрипторов (младшие 32 бита) |
| `bg_free_blocks_count_lo` | `__le16`   | Количество свободных блоков в группе        |
| `bg_free_inodes_count_lo` | `__le16`   | Количество свободных дескрипторов в группе         |
| `bg_used_dirs_count_lo`   | `__le16`   | Количество каталогов в группе               |
| `bg_flags`                | `__le16`   | Флаги состояния группы                      |
| `bg_exclude_bitmap_lo`    | `__le32`   | Блок битовой карты снимков исключения (Exclusion Snapshot)          |
| `bg_block_bitmap_csum_lo` | `__le16`   | Контрольная сумма битовой карты блоков                  |
| `bg_inode_bitmap_csum_lo` | `__le16`   | Контрольная сумма битовой карты дескрипторов            |
| `bg_itable_unused_lo`     | `__le16`   | Количество неинициализированных индексных дескрипторов  |
| `bg_checksum`             | `__le16`   | Контрольная сумма дескриптора группы        |

... и другие поля

Последующие группы могут хранить также избыточные копии суперблока и таблицы дескрипторов групп, но система будет обращаться к ним в том случае, если начало диска было повреждено

> Источник: <https://docs.kernel.org/next/filesystems/ext4/group_descr.html>

Далее идет битовая карта блоков (Block Bitmap). В ней один бит, равный 1, обозначает, занят ли конкретный блок с тем же индексом

Затем расположена подобная битовая карта для индексных дескрипторов (Inode Bitmap), где бит 1 обозначает, занят ли индексный дескриптор в таблице дескрипторов

> Источник: <https://docs.kernel.org/next/filesystems/ext4/bitmaps.html>

После этого расположена сама таблица индексных дескрипторов. Таблица представляет собой массив дескрипторов, где индекс - это номер индексного дескриптора

Для специальных индексных дескрипторов выделены особые индексы:

* `0` для дескриптора, который не существует
* `1` для списка бракованных блоков
* `2` для корневого каталога `/`
* `3` для пользовательской квоты
* `4` для квоты групп

    Квоты хранят информацию о том, сколько разрешено максимально иметь дескрипторов и/или блоков пользователям и группам

* `5` для загрузчика. Сейчас он редко используется, так как рекомендуется устанавливать загрузчик на другой раздел диска
* `6` для каталога восстановления
* `7` для зарезервированной группы дескрипторов для увеличения количества дескрипторов файловой системы
* `8` для журнала, чтобы обеспечивать надежность данных во время сбоя

9-ый и 10-ый дескрипторы зарезервированы и используются для функций, который обозначены `?` в документации, а 11-ый дескриптор - первый не зарезервированный, но обычно используется для каталога `/lost+found/`, который предназначен для восстановленный утилитой `fsck` файлов после сбоя

> Источник: <https://www.kernel.org/doc/html//latest/filesystems/ext4/special_inodes.html>

Наконец, после таблицы индексных дескрипторов дальше идут сами блоки данных

![Разметка в ext4](./images/admlinux_ext4_layout.png)

---

В файловой системе ext3 добавилась система журналирования - способ восстановления данных в результате нештатной работы ОС или диска

Всего есть три типа журналов в ext3:

1. Journal - самый медленный, но самый надежный журнал. Сначала в журнал пишутся блоки данных, потом они копируются в нужное место, а дескриптор изменяется
2. Ordered - то же самое, но записываем только метаданные файла, что быстрее
3. Writeback - сначала пишем весь файл, а потом изменяем все метаданные в дескрипторе и журнале

В системе ext4 добавилось много новых функций, которые убирали ограничения старых версий системы:

* Экстенты вместо блочной адресации

    Вместо хранения списка отдельных блоков используются экстенты, что уменьшает фрагментацию и ускоряет работу с большими файлами

* Поддержка больших файлов (до 16 Тб в стандартной конфигурации) и файловой системы (теоретически до 1 Эб)
* Отложенное выделение блоков - блоки выделяются не сразу при записи, а позже, что улучшает размещение данных и снижает фрагментацию
* Контрольные суммы журнала уменьшают риск повреждения данных при сбоях
* Возможность дефрагментации без размонтирования файловой системы
* Можно увеличить размер файловой системы во время работы диска
* Предварительное выделение места для файлов
* Метки времени с точностью до наносекунд, тогда как в ext3 только до секунд
* Индексация больших каталогов с использованием хеш-дерева

---

Хорошей практикой является разделение диска на 6 разделов:

* Раздел для EFI (Extensible Firmware Interface), который хранит загрузчики (например, GRUB) и отформатирован в файловую систему FAT
* Раздел для каталога `/boot/`, хранящий ядро и `initramfs`
* Раздел для корневого каталога `/`
* Раздел для файла подкачки
* Раздел для домашнего каталога `/home/`
* И раздел для каталога `/var/`, содержащего изменяемые файлы

В корневом каталоге Linux создает множество подкаталогов для работы системы, структура которых подчиняется стандарту (FHS) Filesystem Hierarchy Standard:

* `/bin/` - каталог с готовыми к исполнению основными программами (например, `/bin/bash`). Оболочки, такие как bash, ищут исполняемые файлы с именем там
* `/sbin/` - системные исполняемые файлы для администрирования (например, `fsck`, `mount`), которые обычно предназначены для суперпользователя
* `/boot/` - файлы, необходимые для загрузки системы: ядро Linux, `initramfs`, конфигурация загрузчика
* `/dev/` - файловые дескрипторы устройств
* `/etc/` (от Editable Text Configuration или Extended Tool Chest) - системные конфигурационные файлы такие, как настройки служб, сети, пользователей и всей системы

* `/home/` - домашние каталоги обычных пользователей
* `/root/` - домашний каталог суперпользователя

* `/lib/`, `/lib64/` - системные библиотеки, необходимые для работы программ из `/bin/` и `/sbin/`
* `/media/` - точки монтирования съемных носителей
* `/mnt/` - временное монтирование файловых систем администратором
* `/opt/` - дополнительные пакеты
* `/proc/` - виртуальная файловая система с информацией о процессах и ядре, создающаяся динамически
* `/sys/` - виртуальная файловая система с информацией о устройствах и драйверах.
* `/run/` - временные данные времени выполнения, например, текущие вошедшие пользователи или запущенные демоны
* `/tmp/` - временные файлы, которые очищаются после перезагрузки. В некоторых случаях каталог `/tmp/` может храниться непосредственно в оперативной памяти

* `/usr/` - пользовательские программы и данные (большинство установленного ПО):

    * `/usr/bin` - программы
    * `/usr/lib` - библиотеки
    * `/usr/src/` - исходный код
    * `/usr/share` - общие данные, которые не зависят от архитектуры

* `/var/` - изменяемые данные, такие как:
    * `/var/log/` - логи
    * `/var/lib/` - персистентная информация программ (например, базы данных)
    * `/var/lock/` - блокировки ресурсов
    * `/var/cache/` - кэш
    * `/var/spool/` - очереди печати, почтовых запросов и так далее
    * `/var/mail/` - данные почтовых серверов
    * `/var/tmp/` - временные файлы, которые нужно сохранить после перезагрузки

