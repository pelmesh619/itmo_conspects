import os
import re
from pathlib import Path
from urllib.parse import quote

from assets.build.superconspect_builder import SuperconspectBuilder


class MarkdownSuperconspectBuilder(SuperconspectBuilder):
    DISCLAIMER = f"<!-- This file is generated by {__module__}. All changes to it will be lost -->\n\n"
    BEGIN_FILE_LABEL = "<!-- begin {} -->\n"
    END_FILE_LABEL = "\n<!-- end {} -->\n\n"

    FILE_EXTENSION = '.md'

    def __init__(self, input_folder, blacklist_words, output_filename=None):
        super().__init__(input_folder, blacklist_words, output_filename)

        self.level = len(list(i for i in os.path.split(input_folder) if i))

        self.table_of_contents = {}
        self.script_sources = []
        self.first_level_header = None

    def filter(self, file_text):
        return re.sub(r'(\t\r )*\#\s*ignore.*?((\#\s*noignore)|($))', '', file_text, flags=re.UNICODE | re.DOTALL).strip()

    def collect_headers(self, file_text):
        new_text = file_text
        for header_match in re.finditer(r'(^|\n)((#+)\s+(.+))\n', file_text):
            # for cases when '\n# ...' is a comment in code block
            if file_text[:header_match.start(2)].count('```') % 2 == 1:
                continue

            header_level = len(header_match.group(3))
            header_name = header_match.group(4).strip()

            header_link = quote(header_name.lower().replace(' ', '-'), safe='', encoding='utf8')

            # for duplicate headers
            temp = header_link
            counter = 1
            while temp in self.table_of_contents:
                temp = header_link + f'-{counter}'
                counter += 1

            header_link = temp

            self.table_of_contents[header_link] = (header_name, header_level)

            if not self.first_level_header and header_level == 1:
                self.first_level_header = (header_name, header_link)
                new_text = new_text.replace(header_match.group(2), "", 1)
            else:
                new_text = new_text.replace(
                    header_match.group(2),
                    self.make_header_with_link(header_name, header_link, header_level),
                    1
                )

        return new_text

    def make_header_with_link(self, text, link, level):
        return '#'*level + f' <a name="{link}"></a> ' + text

    def collect_scripts(self, file_text):
        for script in re.finditer(r'\<script.*\>.*?\<\/script\>\n', file_text, re.U | re.DOTALL):
            if script.group(0) not in self.script_sources:
                self.script_sources.append(script.group(0))
            file_text = file_text.replace(script.group(0), "")

        return file_text

    def make_toc(self):
        table_of_contents = ''
        for link, (header, header_level) in self.table_of_contents.items():
            table_of_contents += '  ' * (header_level - 1) + '* ' + f'[{header}](#{link})\n'

        return table_of_contents

    def build(self, args):
        folder_files = [i for i in os.listdir(self.input_folder) if not i.startswith('__')]
        folder_files.sort()

        text = ''

        for i in folder_files:
            if not i.endswith('.md') or any([j in i for j in self.blacklist_words]):
                continue

            t = open(os.path.join(self.input_folder, i), 'r', encoding='utf8').read()

            t = self.filter(t)

            if not t:
                print(f'File `{i}` ignored')
                continue

            t = self.collect_scripts(t)
            t = self.collect_headers(t)

            text += self.BEGIN_FILE_LABEL.format(i)
            text += t.strip()
            text += self.END_FILE_LABEL.format(i)

        toc = self.make_toc()

        beginning = self.DISCLAIMER

        beginning += '\n'.join(self.script_sources) + '\n'
        if self.first_level_header:
            beginning += self.make_header_with_link(*self.first_level_header, 1) + '\n\n'
        else:
            print("Warning: there is no first level header")

        beginning += toc + '\n'

        open(self.superconspect_filename, 'w', encoding='utf8').write(beginning + text)
