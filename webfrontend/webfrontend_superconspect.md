# <a name="web-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0%3A-frontend"></a> Web-разработка: Frontend


* [Web-разработка: Frontend](#web-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0%3A-frontend)
  * [Лекция 1. Как устроен Web?](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-1.-%D0%BA%D0%B0%D0%BA-%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD-web%3F)
  * [Лекция 3. Блочная модель](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-3.-%D0%B1%D0%BB%D0%BE%D1%87%D0%BD%D0%B0%D1%8F-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C)
* [X. Программа экзамена](#x.-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0-%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0)



## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-1.-%D0%BA%D0%B0%D0%BA-%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD-web%3F"></a> Лекция 1. Как устроен Web?

Всемирная паутина (World Wide Web, или же просто Web) - распределенная система компьютеров, предоставляющая доступ к связанным между собой документам

Сейчас же веб используется для просмотра веб-страниц с контентом, таким как текст, видео, музыка и другое, но что же происходит, когда мы вводим адрес веб-сайта в строке браузера?

Для этого браузер, специальная программа для доступа и обработки веб-страниц, отправляет запрос DNS-серверу

В сети Интернет для непосредственного доступа к другому компьютеру не используются URL-адреса (Uniform Resource Locator), которыми мы пользуемся и которые мы легко понимаем, например `itmo.ru`. Вместо них используются IP-адреса (например, `247.207.70.150`), которые присвоены каждому компьютеру в Интернете

Чтобы по URL-адресу получить IP-адрес, браузер делает запрос DNS-серверу, который возвращает IP-адрес сервера

> Подробнее про DNS - [https://pelmesh619.github.io/itmo_conspects/telecomm/telecomm_superconspect.html#-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-12-dns](https://pelmesh619.github.io/itmo_conspects/telecomm/telecomm_superconspect.html#-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-12-dns) 

Далее браузер делает запрос этому серверу на получение веб-страницы. Основным протоколом в обмене веб-страниц и совершении других запросов является HTTP, HyperText Transfer Protocol (Протокол передачи гипертекста). HTTP работает поверх протокола TCP. Сейчас использует более безопасная версия HTTPS (HTTP Secured). Для создания запроса браузер создает TCP-соединение между текущим компьютером и сервером. Для браузеры выбирается случайный TCP-порт больше 1024, а для сервера порт заранее известен: 80 для HTTP и 443 для HTTPS. Имя протокола указывается в начале полного адреса, например, `https://itmo.ru`

Веб-сервер, компьютер, принявший запрос, имеет специальное программное обеспечение, которое обрабатывает запрос. Основной функцией веб-сервера является хранение, обработка и передача веб-страниц. Имя страницы представляет собой путь после доменного имени и в простейшем случае может быть файлом на веб-сервере, например, `https://itmo.ru/promo/itmo-logo-dark.svg`

Если веб-страница по данному адресу существует, то сервер отправляет ее. Ответ содержит HTTP-код, например, 200, что означает успешный запрос. Если запрошенной страницы нет, то отправляется ответ с кодом 404 и страница-заглушка. Дополнительно, сервер может отправить код 304, что означает, что страница не изменилась, и браузер может загрузить ее из своего кеша

Далее TCP-соединение закрывается, и полученный контент обрабатывается. Сейчас все веб-страницы представляют из себя набор документов из HTML-файла, стилей и скриптов. Браузер обрабатывает HTML-код, обнаруживает дополнительные ресурсы, которые нужны для работы страницы, такие, как изображения, стили, скрипты и прочее, и загружает их, делая дополнительные запросы

![Запросы](./images/webfrontend_web_queries.png)

После этого браузер дополнительно анализируется HTML-код, содержащий в себе структуру страницы. HTML-код, состоящий из тегов, парсится, создается документно-объектная модель страницы

Далее обрабатываются стили, задающие обертку блоков, форматирование текста и другую стилизацию страницы, после чего страница рендерится в окне браузера. Затем запускаются скрипты, написанные на языке JavaScript, которые делают страницу интерактивной 

---

Основная задача фронтенд-разработчика - создать надежный, быстрый и удобный мост между бэкендом и пользователем, реализовав весь сложный интерфейс, который работает на стороне клиента, несмотря на то, какое устройство имеет пользователь, телефон с маленьким экраном и широкий дисплей



## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-3.-%D0%B1%D0%BB%D0%BE%D1%87%D0%BD%D0%B0%D1%8F-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C"></a> Лекция 3. Блочная модель

Каждому HTML-элементу соответствует прямоугольная область, или бокс. Боксы бывают _блочными_ и _строчными_

Блочные бокс представляется собой крупную неразрывную область. Блочными боксами обладают теги `<p>`, `<h1>`, `<h2>`, `<ul>` и так далее. В частности, тег `<div>`, благодаря которому можно создать сетку элементов, обозначает простой прямоугольный контейнер и обладает блочным боксом

Блочные боксы:

* Занимают все доступное пространство по горизонтали
* Имеют задаваемые ширину, высоту, внутренние отступы (padding) и внешние отступы (margin)

    ![html element box](images/webfrontend_html_element_box.png)

* До и после блочного бокса существует перенос строки

Строчные боксы располагаются друг за другом в одной строке, могут разрываться и находиться на нескольких строках. Строчными боксами обладают такие элементы, как `<span>`, `<a>`, `<i>`, `<em>`, `<b>`, `<strong>`, и предназначены для оформления текста

Строчные боксы не имеют переносов до и после бокса, а также для строчных боксов можно задавать только горизонтальные отступы

При рендере HTML-страницы создает поток элементов - порядок их отображения на странице. Блочные элементы располагаются в поток сверху вниз, а строчные - слева направо. Элемент считается выпавшим из потока, если он не влияет на расположение последующих блоков

---

По умолчанию, блочные боксы имеют ширину родительского блока, а высота зависит от содержимого (если бокс пустой, то `0px`). Ширина и высота боксов задаются с помощью свойств `width` и `height`, например:

```css
selector {
    width: 100px;
    height: 100px;
}
```

Чтобы вернуть значения по умолчанию, можно воспользоваться значением `auto`:

```css
selector {
    width: auto;
    height: auto;
}
```

Строчные боксы имеют ширину и высоту ровно столько, сколько занимает контент внутри, и не реагируют на свойства `width` и `height`

Внутренние отступы (или поля) задаются свойством `padding`:

```css
selector {
    padding: 10px; /* отступ 10 пикселей со всех сторон */
}
```

Есть 4 формы записи:

* `padding: 10px;` - 10 пикселей со всех сторон
* `padding: 10px 50px;` - 10 пикселей сверху и снизу, 50 пикселей слева и справа
* `padding: 10px 50px 30px;` - 10 пикселей сверху, 30 пикселей слева и справа, 30 пикселей снизу
* `padding: 10px 50px 30px 80px;` - 10 пикселей сверху, 50 пикселей справа, 30 пикселей снизу, 80 пикселей слева

![padding examples](images/webfrontend_padding_examples.png)

Можно задать отступ для каждой стороны:

```css
selector {
    padding-left: 10px;   /* слева  */
    padding-right: 10px;  /* справа */
    padding-top: 10px;    /* сверху */
    padding-bottom: 10px; /* снизу  */
}
```

Аналогично задаются внешние отступы от границы с помощью свойств `margin`, `margin-top`, `margin-bottom`, `margin-left`, `margin-right`

Также для боксов можно указать границу (или рамку), а именно:

* её стиль с помощью `border-style`, существуют сплошная `solid`, пунктирная `dashed`, точками `dotted`, двойная `double`
* её ширину с помощью `border-width`
* её цвет с помощью `border-color`

У этих свойств также есть конкретные для каждой стороны, например `border-left-width`. С помощью свойства `border` можно указать сокращенную запись этих параметров в любой порядке:

```css
selector {
    border: 20px solid red;
    border-left: 20px dashed green;
    border-bottom: 10px solid blue;
}
```

![border examples](images/webfrontend_borders_examples.png)

Также углы рамок можно скруглять под определенным радиусом с помощью свойств `border-radius`, `border-top-radius`, `border-left-radius`, `border-right-radius`, `border-bottom-radius`

Занимаемое место бокса на странице вычисляется как сумма 

* ширины/высоты, которые занимает контент или которые установлены в свойствах
* внутренние отступы
* толщина границ
* внешние отступы

Вертикальные отступы двух соседних элементов имеют свойство [схлопываться](https://developer.mozilla.org/ru/docs/Web/CSS/CSS_box_model/Mastering_margin_collapsing), тогда интервал между ними становится равным максимуму отступов этих элементов

![margin collapse](images/webfrontend_margin_collapse.png)

Также внешние отступы схлопываются, если у родительского элемента есть внешний отступ, нет внутреннего, а у первого (или последнего) элемента есть внешний отступ, тогда этот отступ будет выпадать за пределы родительского элемента. Фиксится такой прикол при помощи внутреннего отступа у родителя с нужной стороны

---

Теперь можно научиться базовому приему центрирования элемента:

1. Делаем ширину дочернего элемента меньше ширины родителя
2. Делаем внешние отступы слева и справа `auto`

Получаем:

```css
div {
    width: 70%;
    margin: 0 auto;
}
```

Ширину для элемента можно указать в процентах от ширины родительского элемента. Нужно быть аккуратным, так как если родительский элемент имеет внутренний отступ слева и справа, то `width: 100%` может привести к выпаданию элемента за пределы

Кроме `auto` такое исправить можно с помощью изменения свойства `box-sizing`. По умолчанию, оно равно `content-box`, что определяет ширину и высоту для области с контентом. Значение `border-box` установит, что ширина и высота задана для области контента, внутренних отступов и границ

![width 100%](images/webfrontend_width_100per.png)

---

Тип бокса можно изменить с помощью свойства `display`

* `display: block;` установит блочный тип бокса
* `display: inline;` установит строчный тип бокса
* `display: inline-block;` установит блочно-строчный тип бокса

    Блочно-строчному типу бокса можно задавать размеры и отступы, их ширина зависит от содержания, но такой тип не порождает переносы строки до и после себя

* `display: none;` сделает так, что элемент перестанет рендериться и не повлияет на расположение других (в отличии от `visibility: hidden`, при котором элемент не выпадает из потока)
* `display: table;` задает табличный бокс - он похож на блочный, только ширина зависит от контента внутри

Позиционирование элемента также можно изменить. Тип позиционирования можно выбрать с помощью свойства `position`:

* `position: static;` задает статичное позиционирование и стоит по умолчанию, при нем свойства `top`, `left`, `right`, `bottom` не оказывают эффект
* `position: relative` задает позиционирование относительно исходного положения блока
* `position: absolute` задает позиционирование абсолютное, при этом блок выходит из потока, тем самым не влияя на расположение других, а свойства `top`, `left`, `right`, `bottom` указывают положение относительно ближайшего предка, имеющего `position != static`
* `position: fixed` задает положение относительно окна браузера, при этом блок выходит из потока
* `position: sticky` не меняет исходного положения, но при прокрутке вместо того, чтобы выйти за границы окна браузера, элемент остается на указанное расстоянии

Позиционирование задается с помощью свойств `top`, `left`, `right`, `bottom`. Например, `top: 10px; position: relative;` сделает элемент на 10 пискелей ниже исходного положения, а `right: 20px; position: relative;` сделает его на 20 пикселей правее от исходного положения. Также можно применять отрицательные значения

![Позиционирование](images/webfrontend_position.png)

Как можно заметить в примере, элементы перекрывают друг друга. Чтобы изменить порядок перекрытия, нужно указать свойства `z-index` для элемента. Чем больше число `z-index`, тем выше приоритет того, что элемент окажется выше других

Также элементу можно включить обтекание с помощью свойства `float`:

* `float: left;` прижимает элемент к левому краю родителя, другие строчные элементы обтекают его справа
* `float: right;` - то же самое, но с правой стороны
* `float: none;` - отключает обтекание, по умолчанию

Если `float` указан у строчного, то его поведение проявляется как у блочного. Блоки с `float` выпадают их потока. Если у нескольких обтекаемых элементов нет места, то они переносятся на следующих строчки - таким образом создавались сетки элементов в 2000-ых до появления `display: flex` и `display: grid`. Сейчас для сеток лучше использовать `flex` или `grid`, так как поведение переноса обтекаемых элементов может быть неочевидным

Свойство `clear: left` запрещает обтекание слева, `clear: right` - справа, `clear: both` - с обеих сторон




# <a name="x.-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0-%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0"></a> X. Программа экзамена

1. Как устроен браузер, в чем заключается его задача. Назовите какие внутренние программные компоненты есть внутри и какие задачи они решают.
2. Что такое URL? Расскажите из каких частей состоит URL? Как браузер понимает по URL на какой сервер должен пойти ваш HTTP запрос?
3. В каком виде представлен документ внутри вашего браузера? Какие вы знаете способы взаимодействия с элементами, представленными в разметке страницы.
4. Из каких обязательных тэгов должна состоять веб страница? Какая секция для чего предназначена? Какие отличия будут, если мы будет размещать скрипты в начале документа, а не в конце?
5. Что такое CSS? Как применять различные правила и по каким признакам мы можем выбирать элементы на странице.
6. Какие виды вёрстки вы знаете? Какие подходы для верстки страниц существуют? Назовите плюсы и минусы данных подходов.
7. Какие средства реализации объектно-ориентированного програмирования существуют в JavaScript. С помощью каких вспомогательные классов, добавленных в последних стандартах языка, можно достичь полноценной инкапсуляции?
8. Как устроен Event Loop, какие типы задач бывают, в какие очереди выполнения они попадают?
9. С помощью каких встроенных возможностей языка JS происходит взаимодействие между клиентом и сервером? В каком виде обычно предоставляются данные и как их десериализовать?
10. Подходы применяемых при разработке приложений (страниц) для устаревших браузеров. Назовите пример решения ситуации, когда технология, которую вы решили использовать на странице, может быть вдруг недоступна.
11. Устройство нативных веб компонентов. Какие инструменты позволяют нам создать свой собственный компонент для дальнейшего переиспользования? Какие могут вылезти подводные при использовании нативных веб компонентов?
12. Web-Framework’и. Какие типы фреймворков бывают? В чём отличие фреймворка от библиотеки? Какие обязательные компоненты идут из коробки в современных фреймворках? Назовите несколько примеров



