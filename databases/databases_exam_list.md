## X. Программа экзамена 2024/2025

Экзаменационный билет состоит из двух вопросом: один вопрос из списка из диапазона 1-25, второй - из диапазона 26-50. Данный список может быть приблизительным на тот, что будет на экзамене

1.	База данных как компонент информационной системы. Определение понятия данные, связь с функциями ИС. Абстрагирование данных от методов их обработки. Многозвенная архитектура ИС.

    > **[Данные](#data_definition)** (ISO / IEC 2382:2015) - поддающееся многократной интерпретации представление информации в формализованном виде, пригодном для передачи, интерпретации или обработке

    Выделяют 5 информационных процессов:

    * Сбор
    * Обработка
    * Хранение
    * Передача
    * Представление

    <!-- ну я хз, че еще тут добавить -->

2.	Определения базы данных и СУБД по Конноли, Дейту и Хомоненко. Их сходства и различия.

    > 1) (по Коннолли и Беггу) [База данных](#database_connolly_begg) - совместно используемый набор логически связных данных и описание этих данных, предназначенный для удовлетворения информационных потребностей организаций

    > 2) (по Дейту) [База данных](#database_date) - набор постоянно хранимых данных, используемых прикладными системами предприятия

    > 3) (по Хомоненко) [База данных](#database_khomonenko) - совокупность специальным образом организованных данных, хранимых в памяти вычислительной системы и отображающих состояние объектов и их взаимосвязей в рассматриваемой предметной области

    > 1) (по Коннолли, Беггу, Дейту) [СУБД](#dbms_connolly_begg_date) - ПО, с помощью которого пользователи могут определять, создавать и поддерживать базу данных, а также осуществлять контролируемый к ней доступ

    > 2) (по Хомоненко) [СУБД](#dbms_khomonenko) - комплекс языковых и программных средств, предназначенный для создания, ведения и совместного использования базы данных многими пользователями

3.	Файловые хранилища. Недостатки. Упорядоченные и неупорядоченные файлы.
4.	Трехуровневая архитектура ANSI/SPARC.
5.	Модель сущность-связь. Классификации сущностей, атрибутов и связей. Нотация Чена для представления модели сущность-связь.
6.	Логическая и физическая модели данных. Содержание уровней.
7.	Иерархическая и сетевая модели данных: составы моделей, преимущества и недостатки.

    [Идея в иерархической модели данных](#hierarchical_model) состоит в том, чтобы хранить данные в деревьях. 

    > Поле данных - атомарная (неделимая) единица данных

    > Сегмент данных - совокупность полей данных

    Пример: ФИО, название отдела, телефон - это **поля данных**, сотрудник с этими полями - **сегмент данных**, а Иванов Иван Иванович с отделе маркетинга с телефоном +7(777)777-77-77 - **экземпляр сегмента сотрудника**. Тут же введем отдел с названием и именем начальника. В конце концов появляется огромное дерево, в котором можно узнать информацию об отделе от конкретного сотрудника.

    Достоинства:

    1) _Легкость проектирования_ - в принципе все в этом мире можно представить как дерево

    Недостатки:

    1) _Дублирование данных_ - пример: сотрудник числится в нескольких отделах, так как сотрудник не может иметь двух родителей-отделов, то придется создавать нового сотрудника-дублера - тратим память и нарушаем целостности

    2) _Сложность поиска сверху вниз_ - мы не сможем быстро получить всех сотрудников конкретного отдела; в этом случае мы можем создать кучу полей `Сотрудник 1`, `Сотрудник 2`, `Сотрудник N`, но число N может быть меньшим, чем нам надо, в таком случае надо будет двигать всю память, чтобы добавить новое поле, либо большая часть этих полей будут не задействованы (такая же проблема в файловых системах ex3, ex4 - количество файлов в них строго ограничено)

    [В сетевой модели](#network_model) мы разрешаем иметь у экземпляра сегмента нескольких родителей. В итоге получаем граф

    Достоинства:

    1) _Экономия памяти_

    2) _Целостность_

    Но мы можем присвоить каждому экземпляру идентификатор и хранить связи пар идентификаторов отдельно и данные отдельно

    Недостатки:

    1) _Обход графа медленный в больших графах_ - та же задача из иерархической модели, нам придется пройтись по всем сотрудникам, чтобы найти сотрудников конкретного отдела

8.	Реляционная и постреляционная модели данных: составы моделей, преимущества и недостатки.

    [В реляционной модели данные](#relational_model) (то есть сущности) хранятся в тиблицах. С точки зрения реляционной (сущность из таблицы образуют отношение эквивалентности (equivalency relation)) модели связей между таблицами нет - для СУБД ID отдела и ID сотрудника - это одинаковый вещи (например, в SQL возможна подобная конкатенация).

    И тут возникает проблема с реляционной базой данных - она _плохо масштабируется_. Добавлять сотруднику еще один телефон - значит двигать всю память для выделения места под новый столбец

    [В постреляционной модели](#postrelational_model) мы снимаем ограничение на неделимость поля, тогда поле можно представить как структуру. 

    Тогда можно хранить все индивидуальные атрибуты в структуре JSON или XML, сериализовать ее и хранить в бинарном виде. Но из-за этого появляются:

    1) _Долгий поиск_ по второстепенным атрибутам

    2) _Нарушение целостности_ - пример: компания, производящая ручки, сделала ребрендинг, теперь придется менять в каждой структуре бренд


9.	Многомерная и объектно-ориентированная модели данных: составы моделей, преимущества и недостатки.

    [Многомерная модель](#multidimensional_model): дается такая таблица фактов

    | Товар | Сотрудник | Месяц | Количество проданных товаров |
    |-------|-----------|-------|------------------------------|
    | T1    | C1        | Янв   | 10                           |
    | T2    | C1        | Янв   | 5                            |
    | T3    | C3        | Фев   | 15                           |


    И чтобы найти количество проданных товаров в марте, нужно пройтись по всей таблице. Тогда сделаем куб (многомерный массив), где оси - это значения товаров, сотрудников и месяцев, диапазоны значений которых фиксированы

    Многомерные модели получаются очень разреженными, неэффективными по памяти (какой-то сотрудник может не продавать конкретный товар), но с очень быстрым доступом. Например: в течение дня приходят какие-то данные, ночью, когда трафик минимальный, модель перестраивается, и на следующий день можно составлять разнообразную аналитику

    [В объектно-ориентированной модели](#object_oriented_model) создается таблица с атрибутами класса, объект записывается как строка в таблицу.

    В этом случае целостность данных гарантируется тем, что данные изменяются только методами объекта, Но если изменить данные в табличке, в файле, получим нецелостный объект

    Можно хранить в объекте вместо данных ключ, который ссылается на данные в бинарном файле, а в методах объекта данные сразу же записываются в файл

10.	Реляционная модель данных: терминология, свойства отношения.
11.	Реляционная модель данных: виды ключей, реализация различных типов связей, виды целостности.
12.	Операции реляционной алгебры: проекция, выборка, объединение, разность, пересечение.
13.	Операции реляционной алгебры: Тета-соединение, эквисоединение, естественное соединение, левое внешнее соединение, полусоединение.
14.	Структура и порядок выполнения предложения Select в SQL.
15.	Алгоритмы реализации соединений отношений в SQL.
16.	Нормализация реляционной модели: избыточность, аномалии, суть метода нормальных форм. Виды зависимостей между атрибутами.

    [Избыточность](#redundant). Рассмотрим такое отношение:

    | ФИО | N группы | 
    |-----|----------|
    |     |          |

    Заметим, что здесь номера групп будут дублироваться - мы должны знать группу для каждого студента, поэтому это дублирование не избыточное. Теперь расширим таблицу - добавим столбец с образовательной программой:

    | ФИО | N группы | ОП |
    |-----|----------|----|
    |     |          |    |

    Добавление ОП добавляет избыточное дублирование: очевидно, что в одной группе студенты изучают одну образовательную программу
        
    > [Аномалия](#anomaly) - состояние базы данных, которое приводит к противоречию или существенно усложняет обработку данных

    Различают 3 типа аномалий:

    1. > Аномалия модификации - изменение значения одной записи повлечет за собой изменение значения в другой записи

        Пример: при изменении у одного студента номера ОП, зависящего от группы, приходится изменять номер ОП в других местах

    2. > Аномалия удаления - при удалении записи может пропасть и другая информация

        Пример: при удалении всех студентов связь "N группы"-"ОП" теряется

    3. > Аномалия добавления - информацию в таблицу нельзя поместить, пока она не полная или требуется дополнительный просмотр таблицы

        Пример: при добавлении нового студента приходится искать номер ОП для других студентов из его группы

    Аномалии приводят к нарушению целостности и дополнительным тратам по времени, поэтому, чтобы избежать этого, модели данных нужно нормализовать - избавить их. 

    [Рассмотрим виды зависимостей атрибутов](#attribute_dependency):

    > Функциональная зависимость: в некотором отношении `x -> y` (`y` зависит от `x`) тогда и только тогда, когда каждому значению `x` соответствует в точности одно значение `y`. Тогда `x` - детерминант, `y` - зависимая часть

    В примере выше номер ОП зависит от номера группы

    > Частичная функциональная зависимость - зависимость неключевого атрибута от части составного потенциального ключа

    Пример: создадим такое отношение студентов:

    | **ФИО** | **N группы** | ОП | Факультет | Форма обучения | 
    |---------|--------------|----|-----------|----------------|
    |         |              |    |           |                |

    В нем сделаем ФИО и N группы первичным ключом; тогда номер ОП частично зависит от этого ключа (потому что номер ОП зависит от номера группы)

    > Полная функциональная зависимость - зависимость неключевого атрибута от всего составного потенциального ключа

    > Транзитивная функциональная зависимость: атрибуты `z` транзитивно зависит от `x`, если найдется такой `y`, что `z` зависит от `y`, а `y` зависит от `x` (`x -> z => Ǝ y : x -> y, y -> z`)

    Чтобы избежать зависимостей модели декомпозируют в нормальные формы. Разберем типы нормальных форм:


17.	Первая и вторая нормальные формы. Примеры.

    > Отношение является **[первой нормальной формой](#first_normal_form)** (1НФ), если все его атрибуты являются простыми

    Так как простоту атрибута мы определяем сами, то принадлежность отношения к 1-ой нормальной форме - чисто условность

    > Отношение является **[второй нормальной формой](#second_normal_form)** (2НФ), если оно находится в 1НФ и каждый неключевой атрибут функционально полно зависит от первичного ключа

    Переделаем таблицу выше в две других: "Студент"


    | ФИО | N группы | Форма обучения | 
    |-----|----------|----------------|
    |     |          |                |

    и "Группа"

    | N группы | ОП | Факультет |
    |----------|----|-----------|
    |          |    |           |

    Все эти отношения являются вторыми нормальными формами. В этом случае мы выиграли по памяти (при большом кол-ве студентов не будет избыточно дублироваться номер ОП), но проигрываем по времени

18.	Третья нормальная форма. Примеры.

    > Отношение является **[третьей нормальной формой](#third_normal_form)** (3НФ), если оно находится во 2НФ и все неключевые атрибуты взаимно независимы и полностью зависят от первичного ключа

    Также существует другое эквивалентное определение

    > Отношение является **третьей нормальной формой** (3НФ), если оно находится во 2НФ и ни один неключевой атрибут не находится в транзитивной функциональной зависимости от потенциального ключа

    Рассмотрим еще раз таблицу с группами:

    | N группы | ОП | Факультет |
    |----------|----|-----------|
    |          |    |           |

    Здесь факультет транзитивно зависит от номер группы, исправим это:

    Таблица "Группа":

    | N группы | ОП |  
    |----------|----|
    |          |    | 

    Таблица "Образовательная программа":

    | ОП | Факультет |  
    |----|-----------|
    |    |           |

    В итоге для получения связи Студент-Факультет нужно объединить целых 3 таблицы

    Заметим, что в отношении без неключевых атрибутов автоматически выполнена 2НФ и 3НФ.

19.	Нормальная форма Бойса-Кодда. Примеры.

    > Отношение является **[нормальной формой Бойса-Кодда](#Boyce_Codd_normal_form)** (БКНФ), если оно находится в 3НФ и детерминанты всех зависимостей являются потенциальными ключами

    Паспорт зависит от номера ИСУ, но ИСУ - это не потенциальный ключ, а его часть. Поэтому переведем отношение в БКНФ:

    Таблица "Проект"

    | ИСУ | ID проекта | Роль |
    |-----|------------|------|
    |     |            |      | 

    Таблица "Паспорт"

    | ИСУ | Паспорт | 
    |-----|---------|
    |     |         |

    Приведем другой пример - таблица лекторов и практиков:

    | ID Дисциплины | ID Лектора | ID Практика |
    |---------------|------------|-------------|
    |               |            |             | 

    Здесь при замене лектора по причине болезни придется заменять его во всех кортежах соответствующей дисциплины.

20.	Четвертая нормальная форма. Примеры.

    > Отношение является **[четвертой нормальной формой](#fourth_normal_form)** (4НФ), если оно находится в БКНФ и не содержит нетривиальных многозначных зависимостей

    Изменим отношение на такое:

    | ID Дисциплины | ID Преподавателя | Роль |
    |---------------|------------------|------|
    |               |                  |      | 

    Здесь нет аномалии модификации, но при этом мы теряем связь лектор-практик (допускается, что некоторые лектора несовместимы с некоторыми практиками 🦆)

21.	Использование индексов для повышения производительности. Виды индексов.

    [Индекс](#index_structure) - двоичное дерево (или другая структура данных), 
    в котором хранятся какой-то атрибут кортежа и адрес на место кортежа на диске. Такую структуру можно хранить в оперативной памяти и с помощью нее по данному атрибуту быстро находить весь кортеж

    > Первичный индекс - индекс, созданный по первичному ключу отношения, которое упорядочено по первичному ключу. 

    > Индекс кластеризации - индекс, созданный по неключевому полю отношения, которое упорядочено по этому полю. Из-за этого отношение группируется в кластеры по значению избранного поля.

    > Вторичный индекс - индекс, построенный по полю не упорядоченного по нему отношения

    > Плотный индекс - индекс, в котором одному узлу соответствует одна запись

    > Разреженный индекс - индекс, в которому одному узлу соответствуют несколько записей

22.	Использование представлений для повышений производительности и безопасности. Виды представлений. Преимущества и недостатки представлений.

    > [Представление](#efficiency_view) - динамически сформированный результат одной или нескольких реляционных операций, выполненных с целью получения нового отношения

    **Материализованное представление** хранится в памяти. В этом случае надо создавать некий таймер или триггер на пересоздание представления, НО:

    * нельзя это делать часто, иначе не получим выигрыш на производительность
    * нельзя делать редко - получится неконсисентность данных

    **Представление заменой** хранится в виде запроса, на который в нужное время заменяется таблица, доступ к котором мы хотим получить. 

    Но, как мы знаем, дополнительные абстракции приводят к ухудшению производительности, но зато мы выигрываем в безопасности: мы можем отдать это представление другой конторе и выдать доступ к только нужным по нашему мнению полям

    [Преимущества представления](#efficiency_view_advantages):

    * _Независимость данных_

    * _Повышение защищенности данных_

    * _Снижение сложности доступа к данным_

    И [недостатки представления](#efficiency_view_disadvantages):

    * _Ограниченные возможности обновления_

    * _Структурные ограничения_

    * _Снижение производительности_

23.	Транзакции. Понятие транзакции. Свойства транзакции.

    > [Транзакция](#transaction_definition) - это последовательность действий с базой данных, в которой либо все действия выполняются успешно, либо не выполняется ни одно из них

    Чтобы последовательность действий называлась транзакцией, нужно соблюдение этих [свойств ACID](#acid_properties):

    * Atomicity - атомарность: транзакция неделима - либо выполняются все действия, либо ни одного

    * Consistency - согласованность: транзакция переводит одно согласованное состояние базы данных в другое согласованное
    состояние базы данных без соблюдения поддержки согласованности в промежуточных точках

    * Isolation - изоляция: если запущено несколько конкурирующих транзакций, то любой обновление, выполненное одной
    транзакцией, скрыто от других до ее завершения

    * Durability - долговечность: когда транзакция завершена, ее результаты сохраняются, даже если в следующий момент
    произойдет сбой

24.	Проблемы конкурирующих транзакций и методы их решения. Уровни изоляции транзакций.

    1. [_Проблема потерянного обновления_](#lost_update_problem): запись на основе неактуальных данных

        Решение - уровень изоляции "_Незавершенное чтение_": требуем, что бы только одна транзакция могла записывать данные

    2. [_Проблема грязного чтения_](#dirty_reading_problem): чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится).

        Решение - уровень изоляции "_Завершенное чтение_": если какая-то транзакция
        изменяет данные, то никакая другая не может их читать

    3. [_Проблема неповторяемого чтения_](#non_repeatable_reading_problem): запись **изменилась** после начала чтения, поэтому транзакция чтения не прочитала эту обновленную запись

        Решение - уровень изоляции "_Воспроизводимое чтение_": если транзакция считывает данные, то никакая другая транзакция не может изменить их

    4. [_Проблема фантомного чтения_](#phantom_reading_problem): новая запись **появилась** после начала чтения, поэтому транзакция чтения не прочитала эту запись

        Решение - уровень изоляции "_Сериализуемость_" (или "_Сериализация_"): если транзакция выполняется к данным, то никакая другая транзакция не может изменять или добавлять записи, если они могут быть прочитаны изначальной транзакцией

25.	Иерархия уровней безопасности по оранжевой книге. Понятия идентификации и аутентификации.

    [**Система класса D**](#safety_system_class_D) - система, которая не подходит под требования безопасности других классов

    [**Система класса C**](#safety_system_class_C) - система, в которой реализованы _подсистемы идентификации, аутенфикации, авторизации_, _учет событий (логгирование)_ и _дискреционный контроль доступа_

    [Система **подкласса C1**](#safety_system_class_C1) предполагает, что существует доверительная вычислительная база - вся процедура от аутентификации до авторизации централизованно контролируется

    [Система **подкласса C2**](#safety_system_class_C2) гарантируется гранулированность субъектов до конкретного пользователя

    [**Система класса B**](#safety_system_class_B) - система, в которой реализован мандатный доступ

    В [**системе подкласса B1**](#safety_system_class_B1) мы сами определяем, какие объекты будут иметь мандатный доступ

    В [**системе подкласса B2**](#safety_system_class_B2) все объекты имеет только мандатный доступ

    В [**системе подкласса B3**](#safety_system_class_B3) вводим отдельную роль "администратор безопасности", который назначает эти метки 

    [**Система класса A**](#safety_system_class_A) предполагает проверенный дизайн: независимая проверка архитектуры, кода на поиск проблем безопасности

    [Понятия](#identification_authentication_authorization) идентификации, аутентификации и авторизации:
    
    > Идентификация - присвоение пользователю идентификатора в базе данных 

    > Аутентификация - сопоставление предъявляемого идентификатора с данным, хранимым в системе

    > Авторизация - предоставление доступ после аутентификации к системе



26.	Избирательный (дискреционный) контроль доступа. Ролевой контроль доступа.

    [Дискреционный контроль доступа](#discrete_access_control) представляет собой матрицу субъекты/объекты:

    |     | O1 | O2 | ... | On |
    |-----|----|----|-----|----|
    | S1  | r  |    |     | r  |
    | S2  |    | ru |     |    |
    | ... |    |    |     |    |
    | Sm  |    |    |     |    |

    На пересечении столбцов и строчек матрицы определены типы доступа CRUD конкретного пользователя для конкретного объекта

    [Ролевая модель доступа](#role_access_control) основана на дискреционном контроле доступе. В ролевой модели мы строим матрицы роли/объекты 

    |     | O1 | O2 | ... | On   |
    |-----|----|----|-----|------|
    | R1  | r  |    |     | r    |
    | R2  |    | ru |     |      |
    | ... |    |    |     |      |
    | Rm  |    |    |     | crud |

    и отдельно матрицу роль-субъект:

    |     | S1 | S2 | ... | Sn |
    |-----|----|----|-----|----|
    | R1  | X  |    |     | X  |
    | R2  |    | X  |     |    |
    | ... |    |    |     |    |
    | Rm  | X  | X  |     |    |

    Благодаря этому субъект может иметь несколько ролей

27.	Мандатный контроль доступа. 

    [Мандатный контроль доступа](#mandat_access_control) работает так: создаем упорядоченный по приоритету набор меток, каждому объекту и субъекту присваиваем эту метку и устанавливаем правила:

    * Пользователь может читать объекты со своей меткой и слабее
    * Пользователь может изменять объекты со своей меткой и сильнее

28.	Аудит и шифрование данных в БД.

    [**Аудит**](#audit) - журналирование, к которому добавляется механизм анализа журнала. Применяется для выявления аномалий в поведении системы и пользователей.

    [**Шифрование**](#encryption) - преобразование информации в целях сокрытия доступа к ней. Выделяют 4 вида:

    * Прозрачное шифрование базы данных: данные шифруются при записи и дешифруются при чтении

    * Шифрование на уровне столбцов: отдельные столбцы дешифруются при чтении

    * Шифрование на уровне файловой системы: драйвер файловой системы перед чтением шифрует данные

    * Шифрование на уровне приложений: данные шифруются в самой базе данных (но невозможно использовать индексы)

29.	Распределенные БД. Определение. Стратегии размещения данных в системе, их достоинства и недостатки. Понятие прозрачности.

    > [Распределенная база данных](#decentralized_database) - набор логически связанных между собой разделяемых данных и их описаний, которые физически располагаются на нескольких вычислительных узлах распределительной сети

    [3 стратегии репликации](#replication_strategies):

    * Раздельное размещение: каждый фрагмент хранится в единственном экземпляре 

        \- медленный узел становится слабым местом

        \+ не надо поддерживать целостность

    * Размещение с полной репликацией: все фрагменты данных реплицируются на всех узлах

        \- надо поддерживать целостность

        \+ надежность (умер один узел, данные есть на других)

    * Размещение с выборочной репликацией: реплицируем какие-то востребованные данные

        \- нужно думать, что куда реплицировать

        \+ оптимально👍

    > [Распределенная СУБД](#decentralized_dbms) - комплекс программ, предназначенный для управления базой данных и позволяющий сделать распределенность информации прозрачной для конечного пользователя

    ["Прозрачная"](#transparency) в определении означает, что распределенная база данных ощущается как единое целое. Тут можно выделить 4 уровня прозрачности:

    * Прозрачность фрагментации: не знаем, как сделаны фрагменты

    * Прозрачность расположения объектов: не знаем, где они расположены

    * Прозрачность количества реплик: не знаем, сколько их

    * Прозрачность контроля доступа: не знаем, как устроен контроль доступа к данным

30.	Двенадцать правил Дейта для распределенных БД.

    [12 правил Дейта](#twelve_dates_rules):

    1. Локальная автономность: локальные данные принадлежат локальным владельцам и сопровождаются локально (данные не могут передаваться горизонтально)

    2. Отсутствие опоры на центральный узел: в системе не должно быть ни одного узла, без которого не может функционировать система

    3. Непрерывное функционирование: в системе не должна возникать потребность в плановой остановке ее функционирования

    4. Независимость от расположения фрагментов: пользователь должен получать доступ, начиная с текущего узла

    5. Независимость от репликации

    6. Независимость от фрагментации

    7. Обработка распределенных запросов: система должна поддерживать обработку запросов с данными, расположенных более чем на одном узле

    8. Обработка распределенных транзакций: система должна поддерживать обработку транзакций с данными, расположенных более чем на одном узле, включая необходимые блокировки

    9. Независимость от типа оборудования

    10. Независимость от сетевой архитектуры

    11. Независимость от операционной системы

    12. Независимость от типа СУБД

31.	Предпосылки к появлению NoSQL баз данных.

    [Предпосылки](#nosql_causes):

    1. Большие данные

    2. Взаимосвязность данных

    3. Слабоструктурированная информация

    4. Архитектура информационных систем

32.	Общие характеристики NoSQL баз данных.

    [4 свойства, определяющие NoSQL решение](#nosql_properties):

    1. No SQL - не использует язык SQL для запросов к себе

    2. Schemaless - неструктурность

    3. Aggregates - аггрегированность

    4. Weak ACID - не делаем ACID, делаем BASE:

        * Вasic Availability - базовая доступность: хранилище обязано ответить через гарантированный определенный промежуток времени
        * Soft state - гибкое состояние: допускаем, что в какой-то момент данные будут не целостны
        * Evential consistency - итоговая консистентность: в конечном счете, целостность данных соблюдется

33.	CAP теорема. Пример.

    > [Теорема CAP](#cap_theorem) гласит, что в распределенной системе хранения данных невозможно соблюсти все эти три свойства: \
    **Consistency** - Согласованность \
    **Availability** - Доступность \
    **Partition tolerance** - Устойчивость к разбиению

    [Пример](#cap_theorem_example):

    Есть бесконечный блокнотик, сотрудник и телефонный номер. Клиенты звонят по телефону, просят одну из трех вещей: добавить запись в блокнотик, удалить запись из блокнотика и посмотреть все записи в блокнотике; сотрудник вносит изменения в блокнотик.

    Если блокнотик один (централизованная система), то очередь к нему может быстро переполнится - соблюдаются только CP

    Если блокнотиков несколько, но они не связаны (система с независимыми узлами с балансировкой нагрузки), то данные между ними не синхронизируются - соблюдаются только AP

    Если блокнотики связаны между собой (распределенная система с транзакционной репликацией данных) и:
    
    * расположены далеко, то не гарантируется, что данные дойдут до них - нарушается Availability

    * расположены близко, чтобы гарантировать доставку данные, то их невозможно разбить на части - нарушается Partition tolerance

34.	NoSQL решения: хранилища ключ-значение и документоориентированные БД.

    [Key-Value](#key_value_store): храним таблицу с двумя колонками: уникальным ключом и примитивным значением; таким образом, соблюдаем высокую производительность

    [Document](#document_store): храним таблицу с двумя колонками: уникальным ключом и значением, которое может быть структурой (словарем с другими ключами, массивом)

35.	NoSQL решения: колоночные и графовые БД.

    [Column based](#column_based_store): храним таблицу, в которой для ячейки может быть расширен или переопределен домен столбца или же добавлен новый столбец, хранящийся отдельно

    [Графовые](#graph_store): храним граф, где вершины - сущности и атрибуты, а связи могут иметь свои свойства

36.	База знаний. Определение, отличие от базы данных, замкнутые и открытые БЗ.

    > [База знаний](#knowledge_base_definition) - совокупность единиц знаний, которые представляют собой формализованные с помощью некоторого метода представления знаний, отражение объектов предметной области и их взаимосвязей, действий над объектами и, возможно, неопределенностей, с которыми эти действия осуществляются

    Базы знаний делятся на [открытые и замнкнутые](#open_closed_knowledge_base):

    * Замкнутые продуцируют знаний на основе заложенных в них знаний - если такую систему спросить о чем-то, что она не знает и не может вывести из существующих знаний, она ответит "не знаю"

    * Открытые базы знаний могут вместо "не знаю" запросить еще данных (допобучение) и к тому же выявлять противоречия


37.	Логическая модель представления знаний.

    [Логическая модель](#logic_knowledge_model) `<T, P, A, B>`, где 

    * `T` - конечный набор неделимых элементов знаний, словарь
    * `P` - множество синтаксических правил или формул, на основании которых из `T` можно получить синтаксически верную конструкцию
    * `A` - набор аксиом, подмножество `P`, которое является истинно, например, `A + B = B + A`
    * `B` - правила вывода, конструкции, с помощью которых из одних верных конструкций получить другие верные конструкции

38.	Сетевая модель представления знаний, виды сетей, онтология.

    [Сетевая модуль](#network_knowledge_model) `<I, C_1, C_2, ..., C_n, G_1, G_2, ..., G_n>`, где

    * `I` - набор информационных единиц
    * `C_i` - типы связей, например, `X является видом Y`, `из X следует Y`
    * `G_i` - графы для каждого типа связей

        Если раскрасить ребра графов и совместить их, то получим онтологию нашей предметной области


39.	Фреймовая модель представления знаний.

    [Фреймовая модель](#frame_knowledge_model) состоит из фреймов, в которых есть пары слотов и значений. Значением может быть какая-то константа либо процедура получения значения

40.	Продукционная модель представления знаний.

    [Продукционная модель](#production_knowledge_model) `<I, Q, P, A -> B, N>`

    * `I` - идентификатор продукции
    * `A -> B` - ядро продукции
    * `Q` - область применения продукции
    * `P` - условия применимость этой продукции
    * `N` - пост-условие выполнения продукции
