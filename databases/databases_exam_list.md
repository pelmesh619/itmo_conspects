## X. Программа экзамена 2024/2025

Экзаменационный билет состоит из двух вопросом: один вопрос из списка из диапазона 1-25, второй - из диапазона 26-50. Данный список может быть приблизительным на тот, что будет на экзамене

1.	База данных как компонент информационной системы. Определение понятия данные, связь с функциями ИС. Абстрагирование данных от методов их обработки. Многозвенная архитектура ИС.
2.	Определения базы данных и СУБД по Конноли, Дейту и Хомоненко. Их сходства и различия.
3.	Файловые хранилища. Недостатки. Упорядоченные и неупорядоченные файлы.
4.	Трехуровневая архитектура ANSI/SPARC.
5.	Модель сущность-связь. Классификации сущностей, атрибутов и связей. Нотация Чена для представления модели сущность-связь.
6.	Логическая и физическая модели данных. Содержание уровней.
7.	Иерархическая и сетевая модели данных: составы моделей, преимущества и недостатки.
8.	Реляционная и постреляционная модели данных: составы моделей, преимущества и недостатки.
9.	Многомерная и объектно-ориентированная модели данных: составы моделей, преимущества и недостатки.
10.	Реляционная модель данных: терминология, свойства отношения.
11.	Реляционная модель данных: виды ключей, реализация различных типов связей, виды целостности.
12.	Операции реляционной алгебры: проекция, выборка, объединение, разность, пересечение.
13.	Операции реляционной алгебры: Тета-соединение, эквисоединение, естественное соединение, левое внешнее соединение, полусоединение.
14.	Структура и порядок выполнения предложения Select в SQL.
15.	Алгоритмы реализации соединений отношений в SQL.
16.	Нормализация реляционной модели: избыточность, аномалии, суть метода нормальных форм. Виды зависимостей между атрибутами.
17.	Первая и вторая нормальные формы. Примеры.
18.	Третья нормальная форма. Примеры.
19.	Нормальная форма Бойса-Кодда. Примеры.
20.	Четвертая нормальная форма. Примеры.
21.	Использование индексов для повышения производительности. Виды индексов.
22.	Использование представлений для повышений производительности и безопасности. Виды представлений. Преимущества и недостатки представлений.
23.	Транзакции. Понятие транзакции. Свойства транзакции.
24.	Проблемы конкурирующих транзакций и методы их решения. Уровни изоляции транзакций.

25.	Иерархия уровней безопасности по оранжевой книге. Понятия идентификации и аутентификации.

    [**Система класса D**](#safety_system_class_D) - система, которая не подходит под требования безопасности других классов

    [**Система класса C**](#safety_system_class_C) - система, в которой реализованы _подсистемы идентификации, аутенфикации, авторизации_, _учет событий (логгирование)_ и _дискреционный контроль доступа_

    [Система **подкласса C1**](#safety_system_class_C1) предполагает, что существует доверительная вычислительная база - вся процедура от аутентификации до авторизации централизованно контролируется

    [Система **подкласса C2**](#safety_system_class_C2) гарантируется гранулированность субъектов до конкретного пользователя

    [**Система класса B**](#safety_system_class_B) - система, в которой реализован мандатный доступ

    В [**системе подкласса B1**](#safety_system_class_B1) мы сами определяем, какие объекты будут иметь мандатный доступ

    В [**системе подкласса B2**](#safety_system_class_B2) все объекты имеет только мандатный доступ

    В [**системе подкласса B3**](#safety_system_class_B3) вводим отдельную роль "администратор безопасности", который назначает эти метки 

    [**Система класса A**](#safety_system_class_A) предполагает проверенный дизайн: независимая проверка архитектуры, кода на поиск проблем безопасности

    [Понятия](#identification_authentication_authorization) идентификации, аутентификации и авторизации:
    
    > Идентификация - присвоение пользователю идентификатора в базе данных 

    > Аутентификация - сопоставление предъявляемого идентификатора с данным, хранимым в системе

    > Авторизация - предоставление доступ после аутентификации к системе



26.	Избирательный (дискреционный) контроль доступа. Ролевой контроль доступа.

    [Дискреционный контроль доступа](#discrete_access_control) представляет собой матрицу субъекты/объекты:

    |     | O1 | O2 | ... | On |
    |-----|----|----|-----|----|
    | S1  | r  |    |     | r  |
    | S2  |    | ru |     |    |
    | ... |    |    |     |    |
    | Sm  |    |    |     |    |

    На пересечении столбцов и строчек матрицы определены типы доступа CRUD конкретного пользователя для конкретного объекта

    [Ролевая модель доступа](#role_access_control) основана на дискреционном контроле доступе. В ролевой модели мы строим матрицы роли/объекты 

    |     | O1 | O2 | ... | On   |
    |-----|----|----|-----|------|
    | R1  | r  |    |     | r    |
    | R2  |    | ru |     |      |
    | ... |    |    |     |      |
    | Rm  |    |    |     | crud |

    и отдельно матрицу роль-субъект:

    |     | S1 | S2 | ... | Sn |
    |-----|----|----|-----|----|
    | R1  | X  |    |     | X  |
    | R2  |    | X  |     |    |
    | ... |    |    |     |    |
    | Rm  | X  | X  |     |    |

    Благодаря этому субъект может иметь несколько ролей

27.	Мандатный контроль доступа. 

    [Мандатный контроль доступа](#mandat_access_control) работает так: создаем упорядоченный по приоритету набор меток, каждому объекту и субъекту присваиваем эту метку и устанавливаем правила:

    * Пользователь может читать объекты со своей меткой и слабее
    * Пользователь может изменять объекты со своей меткой и сильнее

28.	Аудит и шифрование данных в БД.

    [**Аудит**](#audit) - журналирование, к которому добавляется механизм анализа журнала. Применяется для выявления аномалий в поведении системы и пользователей.

    [**Шифрование**](#encryption) - преобразование информации в целях сокрытия доступа к ней. Выделяют 4 вида:

    * Прозрачное шифрование базы данных: данные шифруются при записи и дешифруются при чтении

    * Шифрование на уровне столбцов: отдельные столбцы дешифруются при чтении

    * Шифрование на уровне файловой системы: драйвер файловой системы перед чтение шифрует данные

    * Шифрование на уровне приложений: данные шифруются в самой базе данных (но невозможно использовать индексы)

29.	Распределенные БД. Определение. Стратегии размещения данных в системе, их достоинства и недостатки. Понятие прозрачности.

    > [Распределенная база данных](#decentralized_database) - набор логически связанных между собой разделяемых данных и их описаний, которые физически располагаются на нескольких вычислительных узлах распределительной сети

    [3 стратегии репликации](#replication_strategies):

    * Раздельное размещение: каждый фрагмент хранится в единственном экземпляре 

        \- медленный узел становится слабым местом

        \+ не надо поддерживать целостность

    * Размещение с полной репликацией: все фрагменты данных реплицируются на всех узлах

        \- надо поддерживать целостность

        \+ надежность (умер один узел, данные есть на других)

    * Размещение с выборочной репликацией: реплицируем какие-то востребованные данные

        \- нужно думать, что куда реплицировать

        \+ оптимально👍

    > [Распределенная СУБД](#decentralized_dbms) - комплекс программ, предназначенный для управления базой данных и позволяющий сделать распределенность информации прозрачной для конечного пользователя

    ["Прозрачная"](#transparency) в определении означает, что распределенная база данных ощущается как единое целое. Тут можно выделить 4 уровня прозрачности:

    * Прозрачность фрагментации: не знаем, как сделаны фрагменты

    * Прозрачность расположения объектов: не знаем, где они расположены

    * Прозрачность количества реплик: не знаем, сколько их

    * Прозрачность контроля доступа: не знаем, как устроен контроль доступа к данным

30.	Двенадцать правил Дейта для распределенных БД.

    [12 правил Дейта](#twelve_dates_rules):

    1. Локальная автономность: локальные данные принадлежат локальным владельцам и сопровождаются локально (данные не могут передаваться горизонтально)

    2. Отсутствие опоры на центральный узел: в системе не должно быть ни одного узла, без которого не может функционировать систему

    3. Непрерывное функционирование: в системе не должна возникать потребности в плановой остановке ее функционирования

    4. Независимость от расположения фрагментов: пользователь должен получать доступ, начиная с текущего узла

    5. Независимость от репликации

    6. Независимость от фрагментации

    7. Обработка распределенных запросов: система должна поддерживать обработку запросов с данными, расположенных более чем на одном узле

    8. Обработка распределенных транзакций: система должна поддерживать обработку транзацкий с данными, расположенных более чем на одном узле, включая необходимые блокировки

    9. Независимость от типа оборудования

    10. Независимость от сетевой архитектуры

    11. Независимость от операционной системы

    12. Независимость от типа СУБД

31.	Предпосылки к появлению NoSQL баз данных.

    [Предпосылки](#nosql_causes):

    1. Большие данные

    2. Взаимосвязность данных

    3. Слабоструктурированная информация

    4. Архитектура информационных систем

32.	Общие характеристики NoSQL баз данных.

    [4 свойства, определяющие NoSQL решение](#nosql_properties):

    1. No SQL - не использует язык SQL для запросов к себе

    2. Schemaless - неструктурность

    3. Aggregates - аггрегированность

    4. Weak ACID - не делаем ACID, делаем BASE:

        * Вasic Availability - базовая доступность: хранилище обязано ответить через гарантированный определенный промежуток времени
        * Soft state - гибкое состояние: допускаем, что в какой-то момент данные будут не целостны
        * Evential consistency - итоговая консистентность: в конечном счете, целостность данных соблюдется

33.	CAP теорема. Пример.

    > [Теорема CAP](#cap_theorem) гласит, что в распределенной системе хранения данных невозможно соблюсти все эти три свойства: \
    **Consistency** - Согласованность \
    **Availability** - Доступность \
    **Partition tolerance** - Устойчивость к разбиению

    [Пример](#cap_theorem_example):

    Есть бесконечный блокнотик, сотрудник и телефонный номер. Клиенты звонят по телефону, просят одну из трех вещей: добавить запись в блокнотик, удалить запись из блокнотика и посмотреть все записи в блокнотике; сотрудник вносит изменения в блокнотик.

    Если блокнотик один (централизованная система), то очередь к нему может быстро переполнится - соблюдаются только CP

    Если блокнотиков несколько, но они не связаны (система с независимыми узлами с балансировкой нагрузки), то данные между ними не синхронизируются - соблюдаются только AP

    Если блокнотики связаны между собой (распределенная система с транзакционной репликацией данных) и:
    
    * расположены далеко, то не гарантируется, что данные дойдут до них - нарушается Availability

    * расположены близко, чтобы гарантировать доставку данные, то их невозможно разбить на части - нарушается Partition tolerance

34.	NoSQL решения: хранилища ключ-значение и документоориентированные БД.

    [Key-Value](#key_value_store): храним таблицу с двумя колонками: уникальным ключом и примитивным значением; таким образом, соблюдаем высокую производительность

    [Document](#document_store): храним таблицу с двумя колонками: уникальным ключом и значением, которое может быть структурой (словарем с другими ключами, массивом)

35.	NoSQL решения: колоночные и графовые БД.

    [Column based](#column_based_store): храним таблицу, в которой для ячейки может быть расширен или переопределен домен столбца или же добавлен новый столбец, хранящийся отдельно

    [Графовые](#graph_store): храним граф, где вершины - сущности и атрибуты, а связи могут иметь свои свойства

36.	База знаний. Определение, отличие от базы данных, замкнутые и открытые БЗ.

    > [База знаний](#knowledge_base_definition) - совокупность единиц знаний, которые представляют собой формализованные с помощью некоторого метода представления знаний, отражение объектов предметной области и их взаимосвязей, действий над объектами и, возможно, неопределенностей, с которыми эти действия осуществляются

    Базы знаний делятся на [открытые и замнкнутые](#open_closed_knowledge_base):

    * Замкнутые продуцируют знаний на основе заложенных в них знаний - если такую систему спросить о чем-то, что она не знает и не может вывести из существующих знаний, она ответит "не знаю"

    * Открытые базы знаний могут вместо "не знаю" запросить еще данных (допобучение) и к тому же выявлять противоречия


37.	Логическая модель представления знаний.

    [Логическая модель](#logic_knowledge_model) `<T, P, A, B>`, где 

    * `T` - конечный набор неделимых элементов знаний, словарь
    * `P` - множество синтаксических правил или формул, на основании которых из `T` можно получить синтаксически верную конструкцию
    * `A` - набор аксиом, подмножество `P`, которое является истинно, например, `A + B = B + A`
    * `B` - правила вывода, конструкции, с помощью которых из одних верных конструкций получить другие верные конструкции

38.	Сетевая модель представления знаний, виды сетей, онтология.

    [Сетевая модуль](#network_knowledge_model) `<I, C_1, C_2, ..., C_n, G_1, G_2, ..., G_n>`, где

    * `I` - набор информационных единиц
    * `C_i` - типы связей, например, `X является видом Y`, `из X следует Y`
    * `G_i` - графы для каждого типа связей

        Если раскрасить ребра графов и совместить их, то получим онтологию нашей предметной области


39.	Фреймовая модель представления знаний.

    [Фреймовая модель](#frame_knowledge_model) состоит из фреймов, в которых есть пары слотов и значений. Значением может быть какая-то константа либо процедура получения значения

40.	Продукционная модель представления знаний.

    [Продукционная модель](#production_knowledge_model) `<I, Q, P, A -> B, N>`

    * `I` - идентификатор продукции
    * `A -> B` - ядро продукции
    * `Q` - область применения продукции
    * `P` - условия применимость этой продукции
    * `N` - пост-условие выполнения продукции
