# <a name="%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B1%D0%B0%D0%B7-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85"></a> Проектирование баз данных


* [Проектирование баз данных](#%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B1%D0%B0%D0%B7-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
  * [Лекция 1](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-1)
  * [Лекция 2](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-2)
    * [Реляционная](#%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F)
    * [Колоночная](#%D0%BA%D0%BE%D0%BB%D0%BE%D0%BD%D0%BE%D1%87%D0%BD%D0%B0%D1%8F)
    * [Документоориентированная](#%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F)
    * [Графовая](#%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2%D0%B0%D1%8F)
    * [Ключ-значение](#%D0%BA%D0%BB%D1%8E%D1%87-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5)
    * [Временные ряды](#%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%80%D1%8F%D0%B4%D1%8B)
    * [Векторная](#%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%BD%D0%B0%D1%8F)
    * [Хранилище данных](#%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
    * [Функциональные требования](#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
    * [Нейминг](#%D0%BD%D0%B5%D0%B9%D0%BC%D0%B8%D0%BD%D0%B3)
    * [Паттерны](#%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B)



На этом курсе мы будем проектировать реляционные базы данных с помощью СУБД [PostgreSQL](https://www.postgresql.org/)

Также будут разбираться другие СУБД, реализующие другие модели данных, а также работа с контейнерами.

## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-1"></a> Лекция 1

> Модель данных - это концептуальное описание структуры данных, их взаимосвязей, а также правил и ограничений, регулирующих работу с данными. Система управления БД реализует определенную модель данных

Можно выделить такие модели данных: 

* реляционная
* документоориентированная
* колоночная
* графовая
* ключ-значение
* векторная
* временных рядов (time series)

Модели данных помогают нам преобразовать объекты доменной области в понятные компьютеру образы.

> Нормализация базы данных - это процесс структурирования данных в базе данных в соответствии с определенными правилами, направленный на устранение избыточности данных и обеспечение их целостности. Основная идея нормализации заключается в разбиении больших таблиц на несколько меньших, логически связанных между собой, с целью обеспечения целостности и согласованности данных

Нормальные формы ведут за собой потери производительности при агрегации данных. В каких-то случаях применяется денормализация - обратный процесс, целью которого является увеличение избыточности и производительности

На курсе "Базы данных" мы изучали виды ключей записей в реляционной БД:

> Суперключ - набор одного или нескольких атрибутов, которые в совокупности позволяют уникально идентифицировать каждую запись в таблице

> Потенциальный ключ - минимальный суперключ, который не содержит избыточных атрибутов

> Первичный ключ - один из потенциальных ключей, выбранный для уникальной идентификации записей в таблице

> Внешний ключ - атрибут или множество атрибутов, которые соответствуют потенциальному ключу некоторого (может быть того же самого) отношения

Также ключ может быть естественным и суррогатным

> **Естественный ключ** - это атрибут (или комбинация), который уже присутствует в данных и имеет смысл с точки зрения предметной области 

Пример: адрес электронной почты в базе клиентов

Плюсы: экономия памяти

Минусы: может измениться, может быть неопределенной длины

> **Суррогатный ключ** - искусственно созданный уникальный идентификатор 

Плюсы: не может потребоваться его менять, занимает мало места

Минусы: избыточные данные

Роль суррогатного ключа может принять автоинкремент (увеличенное на 1 значение ключа предыдущей созданной записи) или UUID


Также в PostgreSQL существуют такие типы данных:

* Целочисленные типы - smallint, int, bigint, (serial, big serial)

* С плавающей точкой - real, double, money, decimal

* Строки - varchar, char, text

* Дата и время - date, time, timestamp, interval

* Логический - bool

* Геометрические типы - point, path, line



## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-2"></a> Лекция 2

Как уже говорилось, модели данных со своими преимуществами и недостатками имеют свои области применения, в которых они будут наиболее эффективны

### <a name="%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F"></a> Реляционная

По статистике реляционные базы данных имеют наибольшую популярность в разработке

Реляционная модель организует данные в виде двухмерных таблиц со строгой структурой. Данные вносятся как строки, колонки которых соответствуют определенным типам данных.
Между таблицами, отношениями, можно настроить семантические связи. Реляционные базы данных используют структурированный язык запросов SQL и соответствуют ACID свойствам

Преимущества реляционных баз данных:

* Благодаря строгой структуре и ACID свойствами, обеспечивается целостность данных

* Использование SQL как стандарта облегчает разработку, миграцию и поддержку

* Возможность выполнения сложные агрегирующих запросов

* Большое сообщество

Недостатки:

* Трудно хранить слабоструктурированные данные

* Горизонтальное масштабирование реляционных БД зачастую сложнее реализовать, чем в NoSQL решениях

* При большом количестве взаимосвязанных таблиц схемы становятся громоздким, что бьет по производительности

Применения реляционных БД:

* OLTP-системы ([Online transaction processing](https://ru.wikipedia.org/wiki/OLTP), транзакции небольшого размера обрабатываются с минимальным временем отклика)

* Системы с высокими требованиям к целостности данных

* Данные имеют строгую структуру

Распространенные реализации: PostgreSQL, MySQL, SQLite, MariaDB, Microsoft SQL Server, Oracle DB, YandexDB

### <a name="%D0%BA%D0%BE%D0%BB%D0%BE%D0%BD%D0%BE%D1%87%D0%BD%D0%B0%D1%8F"></a> Колоночная

В колоночных БД вместо того, чтобы хранить каждую запись целиком, данные организуются по столбцам, то есть значения одного атрибута хранятся последовательно, что позволяет оптимизировать запросы над конкретными наборами данных. Колоночные БД считаются NoSQL

Преимущества:

* Оптимизация запросов

* Если атрибут имеет маленький домен (например, перечисление), то, храня их последовательно, можно кодировать их более оптимально, что позволяет сэкономить память

Недостатки:

* Операции, характерные OLTP, работают менее эффективно

* При частых изменениях данных могут возникать проблемы с синхронизацией

Применение:

* Big Data

* OLAP-системы ([Online Analytical Processing](https://ru.wikipedia.org/wiki/OLAP))

* Бизнес-аналитика (отчеты, дашборды)

* Исторические данные 

Реализации: Cassandra, ScyllaDB, Google BigQuery, ClickHouse (колоночная реляционная СУБД)

### <a name="%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F"></a> Документоориентированная

Данные хранятся в виде документов (обычно представляющиеся в формате [BSON](https://ru.wikipedia.org/wiki/BSON)), а не в виде строк таблицы. 
Документы объединяются в коллекции (по аналогии с таблицами, но без обязательного соответствия единой схеме). Причисляется к NoSQL

Преимущества:

* Возможность изменения структуры документов без необходимости модифицировать общую схему БД

* Документы в формате JSON или BSON естественным образом отображаются на объекты в языках программирования

* Простота горизонтальной масштабируемости

Недостатки: 

* Слабая структура (необходимость валидации)

Применение:

* Хранение логов

* OLTP-системы

* Разработка [MVP](https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE_%D0%B6%D0%B8%D0%B7%D0%BD%D0%B5%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%BD%D1%8B%D0%B9_%D0%BF%D1%80%D0%BE%D0%B4%D1%83%D0%BA%D1%82)

* Неструктурированные данные

* Обработка больших объемов данных

Реализации: MongoDB, Firebase Realtime Database, Elasticsearch, Amazon DynamoDB, CouchDB

### <a name="%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2%D0%B0%D1%8F"></a> Графовая

Вместо таблиц и кортежей в графовой БД объектами являются узлы, ребра и их свойства. Графовые БД считаются NoSQL

Преимущества:

* Запросы на поиск путей, обход графа, анализ связей выполняются быстро

* Нет жесткой структуры

* Легко добавлять новые типы связей и узлов без изменения общей схемы

Недостатки: 

* Узкая специализация

Применение:

* Социальные сети

* Системы рекомендаций

* Управление цепочками поставок

* Фрод-анализ (поиск мошеннических активностей)

Реализации: Neo4j, Dgraph

### <a name="%D0%BA%D0%BB%D1%8E%D1%87-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5"></a> Ключ-значение

Данные в "ключ-значение" БД хранятся в виде ключ-значение

Преимущества:

* Операции получаения, вставки, удаления работают за `O(1)`

* Быстрые и требуют мало ресурсов

Недостатки:

* Сложно агрегировать данные или составлять выборку

* Слабая структура

Применение:

* Кэширование данных

* Хранение сессионных данных

* Реализация очередей

* Хранение конфигурационных данных

Реализации: Redis, Memcached, Etcd, Kafka

### <a name="%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%80%D1%8F%D0%B4%D1%8B"></a> Временные ряды

Данные упорядочены по времени (в данном случае ключ - это метка времени)

Преимущества:

* Высокая скорость записи

* Легко делать агрегацию и интерполяцию

* Хранение больших объемов данных

* Анализ данных за определенный промежуток времени

Недостатки: 

* Узкая специализация

Применение:

* Мониторинг и логирование

* Финансовые рынки

* Интернет вещей

Реализации: InfluxDB, TimescaleDB, Prometheus

### <a name="%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%BD%D0%B0%D1%8F"></a> Векторная

Данные хранятся в виде векторов вещественных чисел

Преимущества:

* Легко осуществим поиск похожих векторов (например, алгоритм [HNSW](https://en.wikipedia.org/wiki/Hierarchical_navigable_small_world))

Недостатки:

* Узкая специализация

Применение: кластеры, техническое зрение, машинное обучение

Реализации: Pinecone, Milvus

### <a name="%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85"></a> Хранилище данных

Данных хранятся в виде файлах (текст, аудио, видео и др.) в файловой системе. Помимо этого каждый файл хранит метаданные.
Доступ к файлам осуществляется по их именам и путям в файловой системы

Преимущества:

* Интеграция с ОС и стандартными файловыми менеджерами

* Возможность выстраивания сложной модели доступа

* Возможность сделать CDN (Content Delivery Network)

Недостатки:

* Поиск по содержимому файла непроизводителен

Применение: хранение и распространение файлов

Реализации: Amazon S3, MinIO


### <a name="%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F"></a> Функциональные требования

При проектировании баз данных надо правильно уметь читать и составлять функциональные требования. Функциональные требования - это такой документ, который формально описывает сущности бизнес-логики, их свойства/связи и действия, которые они совершают или над которыми они совершают

Разберем функциональные требования для аналога Twitter:

* Система должна позволять пользователю зарегистрироваться, указав адрес электронной почты (или номер телефона), имя пользователя и пароль
* При регистрации должна осуществляться валидация введенных данных и отправка подтверждения
* Пользователь должен иметь возможность просматривать и редактировать свой профиль
* Пользователь может подписываться на других пользователей и видеть список своих подписок и подписчиков
* Пользователь должен иметь возможность создавать сообщения (твиты) длиной до 280 символой
* Система должна позволять прикреплять к твитам изображения, видео или ссылки
* После публикации твита пользователь может удалить его (либо неявно скрыть его ото всех)
* Пользователь должен иметь возможность ставить лайки
* Пользователь должен иметь возможность переопубликовать чужие твиты
* Пользователь должен иметь возможность отвечать на твиты
* Пользователь должен иметь возможность искать твиты по ключевым словам и хештегам
* Пользователь может управлять параметрами уведомлений
* Пользователь должен иметь возможность управлять видимостью своих твитов
* Возможность блокировки или ограничения доступа для отдельных пользователей

### <a name="%D0%BD%D0%B5%D0%B9%D0%BC%D0%B8%D0%BD%D0%B3"></a> Нейминг

В PostgreSQL используется `snake_case`, отношения называются в множественном числе, а атрибуты в единственном.

В первичных и внешних ключах указывается название отношения, чтобы избежать коллизии при объединении отношений, например, `user_id` и `chat_id`

### <a name="%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B"></a> Паттерны

**Многое-ко-многим**

Тривиальной реализацией связи многое-ко-многим будет являться атрибут первого отношения, в котором будут указаны первичные ключи второго отношения (в формате JSON, через запятую или по-другому), однако это будет не оптимально

Правильно будет сделать отдельное отношение с двумя столбцами, в котором первичным ключом будет пара из ключей первого и второго отношений

**Вертикальное разделение**

Вместо того, чтобы добавлять новые атрибуты в исходное отношение, мы можем создать новое отношение с этим атрибутами. Например:

| user_id | username | email |
| ------- | -------- | ----- |
|         |          |       |

| user_id | big_string | big_binary | biography |
| ------- | ---------- | ---------- | --------- |
|         |            |            |           |

Если во втором отношении поместить малоиспользуемые атрибуты, то мы получим выигрыш в оптимизации

**Фиксированный набор значений**

Фиксированный набор значений можно реализовать несколькими способами:

* Ограничение на уровне кода - например, валидация на уровне бекенда
* Перечисление -`ENUM` в PostgreSQL
* Ограничение -`CONSTRAINT` в PostgreSQL
* Триггер - обработчик, реагирующий на изменения базы данных
* Справочник - отдельная таблица, которая ремаппит значения; позволяет расширять набор

**EAV (Entity-Attribute-Value)**

EAV - отношение с тремя атрибутами:

* Entity - уникальный идентификатор объекта
* Attribute - имя атрибута
* Value - его значение

EAV позволяет хранить данные с динамически изменяемой структурой, когда новые атрибуты могут добавлять без необходимости изменения структуры

**Полиморфные связи**

Допустим, что комментарии можем ставить и на посты, и на картинки. Тогда отношение с комментариями можем представить так:

| comment_id | content | commantable_id | commantable_type |
| ---------- | ------- | -------------- | ---------------- |
|            |         |                |                  |

Здесь `commentable_type` определяет, из какого отношения `commentable_id` будет являться ключом. Однако такой паттерн делает невозможным использование внешнего ключа

**Список смежных вершин**

Каждый кортеж будет хранить в себе указатель на родителя, тем самым моделируя дерево.

Пример:

| name      | id | parent |
| --------- | -- | ------ |
| food      | 1  | null   |
| vegetable | 2  | 1      |
| potato    | 3  | 2      |
| tomato    | 4  | 2      |
| fruit     | 5  | 1      |
| apple     | 6  | 5      |
| banana    | 7  | 5      |

**Вложенное множество**

Вложенное множество (Nested set) - еще один способ моделирования дерева. Дерево можно представить как вложенное множество:

![picture](images/dbdesign_2025_02_19_1.svg)

Вместо хранения указателя на родителя, мы будем хранить указатели на левый и правый концы отрезков:

| name                          | left_end | right_end |
| ----------------------------- | -------- | --------- |
| Одежда                  | 1        | 22        |
| Мужская                | 2        | 9         |
| Женская                | 10       | 21        |
| Костюмы                | 3        | 8         |
| Брюки                    | 4        | 5         |
| Куртки                  | 6        | 7         |
| Платья                  | 11       | 16        |
| Юбки                      | 17       | 18        |
| Блузки                  | 19       | 20        |
| Вечерние платья | 12       | 13        |
| Сарафаны              | 14       | 15        |

Благодаря этому, мы можем с легкостью определить, является ли какой-либо узел потомком другого узла. Изменять структуру такого дерева - задача нетривиальная, поэтому вложенные множества подойдут для тех деревьев, которые будут чаще всего просматриваемые, нежели изменяемые

**Материализованный путь**

Материализованный путь (Materialized path) - еще один способ моделирования дерева, в которым для каждого узла мы храним его путь из корня. Например:

| name      | path  |
| --------- | ----- |
| food      | 1     |
| vegetable | 1.1   |
| potato    | 1.1.1 |
| tomato    | 1.1.2 |
| fruit     | 1.2   |
| apple     | 1.2.1 |
| banana    | 1.2.2 |

При помощи инструкции `LIKE` в SQL мы можем найти всех потомков какого-либо узла. Как и вложенные множества, такой паттерн рекомендуется применять для почти неизменяемых деревьев


