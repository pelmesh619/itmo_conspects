# <a name="%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B1%D0%B0%D0%B7-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85"></a> Проектирование баз данных


* [Проектирование баз данных](#%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B1%D0%B0%D0%B7-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
  * [Лекция 1. Терминология](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-1.-%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F)
  * [Лекция 2. Модели данных](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-2.-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
    * [Реляционная](#%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F)
    * [Колоночная](#%D0%BA%D0%BE%D0%BB%D0%BE%D0%BD%D0%BE%D1%87%D0%BD%D0%B0%D1%8F)
    * [Документоориентированная](#%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F)
    * [Графовая](#%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2%D0%B0%D1%8F)
    * [Ключ-значение](#%D0%BA%D0%BB%D1%8E%D1%87-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5)
    * [Временные ряды](#%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%80%D1%8F%D0%B4%D1%8B)
    * [Векторная](#%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%BD%D0%B0%D1%8F)
    * [Хранилище данных](#%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
  * [Лекция 3. Функциональные требования и паттерны](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-3.-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B)
    * [Функциональные требования](#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
    * [Нейминг](#%D0%BD%D0%B5%D0%B9%D0%BC%D0%B8%D0%BD%D0%B3)
    * [Паттерны](#%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B)
  * [Лекция 4. Архитектура PostgreSQL](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-4.-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0-postgresql)
    * [Postmaster](#postmaster)
    * [Фоновые процессы (Background Workers)](#%D1%84%D0%BE%D0%BD%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B-%28background-workers%29)
    * [Работа с памятью и хранением данных](#%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C%D1%8E-%D0%B8-%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
    * [Обработка SQL-запросов](#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-sql-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2)
    * [MVCC](#mvcc)
    * [Vacuum и Autovacuum](#vacuum-%D0%B8-autovacuum)
  * [Лекция 5. Встреча с Олегом Сергеевичем Бартуновым](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-5.-%D0%B2%D1%81%D1%82%D1%80%D0%B5%D1%87%D0%B0-%D1%81-%D0%BE%D0%BB%D0%B5%D0%B3%D0%BE%D0%BC-%D1%81%D0%B5%D1%80%D0%B3%D0%B5%D0%B5%D0%B2%D0%B8%D1%87%D0%B5%D0%BC-%D0%B1%D0%B0%D1%80%D1%82%D1%83%D0%BD%D0%BE%D0%B2%D1%8B%D0%BC)



На этом курсе мы будем проектировать реляционные базы данных с помощью СУБД [PostgreSQL](https://www.postgresql.org/)

Также будут разбираться другие СУБД, реализующие другие модели данных, а также работа с контейнерами.

## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-1.-%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F"></a> Лекция 1. Терминология

> Модель данных - это концептуальное описание структуры данных, их взаимосвязей, а также правил и ограничений, регулирующих работу с данными. Система управления БД реализует определенную модель данных

Можно выделить такие модели данных: 

* реляционная
* документоориентированная
* колоночная
* графовая
* ключ-значение
* векторная
* временных рядов (time series)

Модели данных помогают нам преобразовать объекты доменной области в понятные компьютеру образы.

> Нормализация базы данных - это процесс структурирования данных в базе данных в соответствии с определенными правилами, направленный на устранение избыточности данных и обеспечение их целостности. Основная идея нормализации заключается в разбиении больших таблиц на несколько меньших, логически связанных между собой, с целью обеспечения целостности и согласованности данных

Нормальные формы ведут за собой потери производительности при агрегации данных. В каких-то случаях применяется денормализация - обратный процесс, целью которого является увеличение избыточности и производительности

На курсе "Базы данных" мы изучали виды ключей записей в реляционной БД:

> Суперключ - набор одного или нескольких атрибутов, которые в совокупности позволяют уникально идентифицировать каждую запись в таблице

> Потенциальный ключ - минимальный суперключ, который не содержит избыточных атрибутов

> Первичный ключ - один из потенциальных ключей, выбранный для уникальной идентификации записей в таблице

> Внешний ключ - атрибут или множество атрибутов, которые соответствуют потенциальному ключу некоторого (может быть того же самого) отношения

Также ключ может быть естественным и суррогатным

> **Естественный ключ** - это атрибут (или комбинация), который уже присутствует в данных и имеет смысл с точки зрения предметной области 

Пример: адрес электронной почты в базе клиентов

Плюсы: экономия памяти

Минусы: может измениться, может быть неопределенной длины

> **Суррогатный ключ** - искусственно созданный уникальный идентификатор 

Плюсы: не может потребоваться его менять, занимает мало места

Минусы: избыточные данные

Роль суррогатного ключа может принять автоинкремент (увеличенное на 1 значение ключа предыдущей созданной записи) или UUID


Также в PostgreSQL существуют такие типы данных:

* Целочисленные типы - smallint, int, bigint, (serial, big serial)

* С плавающей точкой - real, double, money, decimal

* Строки - varchar, char, text

* Дата и время - date, time, timestamp, interval

* Логический - bool

* Геометрические типы - point, path, line



## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-2.-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85"></a> Лекция 2. Модели данных

Как уже говорилось, модели данных со своими преимуществами и недостатками имеют свои области применения, в которых они будут наиболее эффективны

### <a name="%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F"></a> Реляционная

По статистике реляционные базы данных имеют наибольшую популярность в разработке

Реляционная модель организует данные в виде двухмерных таблиц со строгой структурой. Данные вносятся как строки, колонки которых соответствуют определенным типам данных.
Между таблицами, отношениями, можно настроить семантические связи. Реляционные базы данных используют структурированный язык запросов SQL и соответствуют ACID свойствам

Преимущества реляционных баз данных:

* Благодаря строгой структуре и ACID свойствами, обеспечивается целостность данных

* Использование SQL как стандарта облегчает разработку, миграцию и поддержку

* Возможность выполнения сложные агрегирующих запросов

* Большое сообщество

Недостатки:

* Трудно хранить слабоструктурированные данные

* Горизонтальное масштабирование реляционных БД зачастую сложнее реализовать, чем в NoSQL решениях

* При большом количестве взаимосвязанных таблиц схемы становятся громоздким, что бьет по производительности

Применения реляционных БД:

* OLTP-системы ([Online transaction processing](https://ru.wikipedia.org/wiki/OLTP), транзакции небольшого размера обрабатываются с минимальным временем отклика)

* Системы с высокими требованиям к целостности данных

* Данные имеют строгую структуру

Распространенные реализации: PostgreSQL, MySQL, SQLite, MariaDB, Microsoft SQL Server, Oracle DB, YandexDB

### <a name="%D0%BA%D0%BE%D0%BB%D0%BE%D0%BD%D0%BE%D1%87%D0%BD%D0%B0%D1%8F"></a> Колоночная

В колоночных БД вместо того, чтобы хранить каждую запись целиком, данные организуются по столбцам, то есть значения одного атрибута хранятся последовательно, что позволяет оптимизировать запросы над конкретными наборами данных. Колоночные БД считаются NoSQL

Преимущества:

* Оптимизация запросов

* Если атрибут имеет маленький домен (например, перечисление), то, храня их последовательно, можно кодировать их более оптимально, что позволяет сэкономить память

Недостатки:

* Операции, характерные OLTP, работают менее эффективно

* При частых изменениях данных могут возникать проблемы с синхронизацией

Применение:

* Big Data

* OLAP-системы ([Online Analytical Processing](https://ru.wikipedia.org/wiki/OLAP))

* Бизнес-аналитика (отчеты, дашборды)

* Исторические данные 

Реализации: Cassandra, ScyllaDB, Google BigQuery, ClickHouse (колоночная реляционная СУБД)

### <a name="%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F"></a> Документоориентированная

Данные хранятся в виде документов (обычно представляющиеся в формате [BSON](https://ru.wikipedia.org/wiki/BSON)), а не в виде строк таблицы. 
Документы объединяются в коллекции (по аналогии с таблицами, но без обязательного соответствия единой схеме). Причисляется к NoSQL

Преимущества:

* Возможность изменения структуры документов без необходимости модифицировать общую схему БД

* Документы в формате JSON или BSON естественным образом отображаются на объекты в языках программирования

* Простота горизонтальной масштабируемости

Недостатки: 

* Слабая структура (необходимость валидации)

Применение:

* Хранение логов

* OLTP-системы

* Разработка [MVP](https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE_%D0%B6%D0%B8%D0%B7%D0%BD%D0%B5%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%BD%D1%8B%D0%B9_%D0%BF%D1%80%D0%BE%D0%B4%D1%83%D0%BA%D1%82)

* Неструктурированные данные

* Обработка больших объемов данных

Реализации: MongoDB, Firebase Realtime Database, Elasticsearch, Amazon DynamoDB, CouchDB

### <a name="%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2%D0%B0%D1%8F"></a> Графовая

Вместо таблиц и кортежей в графовой БД объектами являются узлы, ребра и их свойства. Графовые БД считаются NoSQL

Преимущества:

* Запросы на поиск путей, обход графа, анализ связей выполняются быстро

* Нет жесткой структуры

* Легко добавлять новые типы связей и узлов без изменения общей схемы

Недостатки: 

* Узкая специализация

Применение:

* Социальные сети

* Системы рекомендаций

* Управление цепочками поставок

* Фрод-анализ (поиск мошеннических активностей)

Реализации: Neo4j, Dgraph

### <a name="%D0%BA%D0%BB%D1%8E%D1%87-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5"></a> Ключ-значение

Данные в "ключ-значение" БД хранятся в виде ключ-значение

Преимущества:

* Операции получаения, вставки, удаления работают за `O(1)`

* Быстрые и требуют мало ресурсов

Недостатки:

* Сложно агрегировать данные или составлять выборку

* Слабая структура

Применение:

* Кэширование данных

* Хранение сессионных данных

* Реализация очередей

* Хранение конфигурационных данных

Реализации: Redis, Memcached, Etcd, Kafka

### <a name="%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%80%D1%8F%D0%B4%D1%8B"></a> Временные ряды

Данные упорядочены по времени (в данном случае ключ - это метка времени)

Преимущества:

* Высокая скорость записи

* Легко делать агрегацию и интерполяцию

* Хранение больших объемов данных

* Анализ данных за определенный промежуток времени

Недостатки: 

* Узкая специализация

Применение:

* Мониторинг и логирование

* Финансовые рынки

* Интернет вещей

Реализации: InfluxDB, TimescaleDB, Prometheus

### <a name="%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%BD%D0%B0%D1%8F"></a> Векторная

Данные хранятся в виде векторов вещественных чисел

Преимущества:

* Легко осуществим поиск похожих векторов (например, алгоритм [HNSW](https://en.wikipedia.org/wiki/Hierarchical_navigable_small_world))

Недостатки:

* Узкая специализация

Применение: кластеры, техническое зрение, машинное обучение

Реализации: Pinecone, Milvus

### <a name="%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85"></a> Хранилище данных

Данных хранятся в виде файлах (текст, аудио, видео и др.) в файловой системе. Помимо этого каждый файл хранит метаданные.
Доступ к файлам осуществляется по их именам и путям в файловой системы

Преимущества:

* Интеграция с ОС и стандартными файловыми менеджерами

* Возможность выстраивания сложной модели доступа

* Возможность сделать CDN (Content Delivery Network)

Недостатки:

* Поиск по содержимому файла непроизводителен

Применение: хранение и распространение файлов

Реализации: Amazon S3, MinIO


## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-3.-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B"></a> Лекция 3. Функциональные требования и паттерны

### <a name="%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F"></a> Функциональные требования

При проектировании баз данных надо правильно уметь читать и составлять функциональные требования. Функциональные требования - это такой документ, который формально описывает сущности бизнес-логики, их свойства/связи и действия, которые они совершают или над которыми они совершают

Разберем функциональные требования для аналога Twitter:

* Система должна позволять пользователю зарегистрироваться, указав адрес электронной почты (или номер телефона), имя пользователя и пароль
* При регистрации должна осуществляться валидация введенных данных и отправка подтверждения
* Пользователь должен иметь возможность просматривать и редактировать свой профиль
* Пользователь может подписываться на других пользователей и видеть список своих подписок и подписчиков
* Пользователь должен иметь возможность создавать сообщения (твиты) длиной до 280 символой
* Система должна позволять прикреплять к твитам изображения, видео или ссылки
* После публикации твита пользователь может удалить его (либо неявно скрыть его ото всех)
* Пользователь должен иметь возможность ставить лайки
* Пользователь должен иметь возможность переопубликовать чужие твиты
* Пользователь должен иметь возможность отвечать на твиты
* Пользователь должен иметь возможность искать твиты по ключевым словам и хештегам
* Пользователь может управлять параметрами уведомлений
* Пользователь должен иметь возможность управлять видимостью своих твитов
* Возможность блокировки или ограничения доступа для отдельных пользователей

### <a name="%D0%BD%D0%B5%D0%B9%D0%BC%D0%B8%D0%BD%D0%B3"></a> Нейминг

В PostgreSQL используется `snake_case`, отношения называются в множественном числе, а атрибуты в единственном.

В первичных и внешних ключах указывается название отношения, чтобы избежать коллизии при объединении отношений, например, `user_id` и `chat_id`

### <a name="%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B"></a> Паттерны

**Многое-ко-многим**

Тривиальной реализацией связи многое-ко-многим будет являться атрибут первого отношения, в котором будут указаны первичные ключи второго отношения (в формате JSON, через запятую или по-другому), однако это будет не оптимально

Правильно будет сделать отдельное отношение с двумя столбцами, в котором первичным ключом будет пара из ключей первого и второго отношений

**Вертикальное разделение**

Вместо того, чтобы добавлять новые атрибуты в исходное отношение, мы можем создать новое отношение с этим атрибутами. Например:

| user_id | username | email |
| ------- | -------- | ----- |
|         |          |       |

| user_id | big_string | big_binary | biography |
| ------- | ---------- | ---------- | --------- |
|         |            |            |           |

Если во втором отношении поместить малоиспользуемые атрибуты, то мы получим выигрыш в оптимизации

**Фиксированный набор значений**

Фиксированный набор значений можно реализовать несколькими способами:

* Ограничение на уровне кода - например, валидация на уровне бекенда
* Перечисление -`ENUM` в PostgreSQL
* Ограничение -`CONSTRAINT` в PostgreSQL
* Триггер - обработчик, реагирующий на изменения базы данных
* Справочник - отдельная таблица, которая ремаппит значения; позволяет расширять набор

**EAV (Entity-Attribute-Value)**

EAV - отношение с тремя атрибутами:

* Entity - уникальный идентификатор объекта
* Attribute - имя атрибута
* Value - его значение

EAV позволяет хранить данные с динамически изменяемой структурой, когда новые атрибуты могут добавлять без необходимости изменения структуры

**Полиморфные связи**

Допустим, что комментарии можем ставить и на посты, и на картинки. Тогда отношение с комментариями можем представить так:

| comment_id | content | commantable_id | commantable_type |
| ---------- | ------- | -------------- | ---------------- |
|            |         |                |                  |

Здесь `commentable_type` определяет, из какого отношения `commentable_id` будет являться ключом. Однако такой паттерн делает невозможным использование внешнего ключа

**Список смежных вершин**

Каждый кортеж будет хранить в себе указатель на родителя, тем самым моделируя дерево.

Пример:

| name      | id | parent |
| --------- | -- | ------ |
| food      | 1  | null   |
| vegetable | 2  | 1      |
| potato    | 3  | 2      |
| tomato    | 4  | 2      |
| fruit     | 5  | 1      |
| apple     | 6  | 5      |
| banana    | 7  | 5      |

**Вложенное множество**

Вложенное множество (Nested set) - еще один способ моделирования дерева. Дерево можно представить как вложенное множество:

![picture](images/dbdesign_2025_02_19_1.svg)

Вместо хранения указателя на родителя, мы будем хранить указатели на левый и правый концы отрезков:

| name                          | left_end | right_end |
| ----------------------------- | -------- | --------- |
| Одежда                  | 1        | 22        |
| Мужская                | 2        | 9         |
| Женская                | 10       | 21        |
| Костюмы                | 3        | 8         |
| Брюки                    | 4        | 5         |
| Куртки                  | 6        | 7         |
| Платья                  | 11       | 16        |
| Юбки                      | 17       | 18        |
| Блузки                  | 19       | 20        |
| Вечерние платья | 12       | 13        |
| Сарафаны              | 14       | 15        |

Благодаря этому, мы можем с легкостью определить, является ли какой-либо узел потомком другого узла. Изменять структуру такого дерева - задача нетривиальная, поэтому вложенные множества подойдут для тех деревьев, которые будут чаще всего просматриваемые, нежели изменяемые

**Материализованный путь**

Материализованный путь (Materialized path) - еще один способ моделирования дерева, в которым для каждого узла мы храним его путь из корня. Например:

| name      | path  |
| --------- | ----- |
| food      | 1     |
| vegetable | 1.1   |
| potato    | 1.1.1 |
| tomato    | 1.1.2 |
| fruit     | 1.2   |
| apple     | 1.2.1 |
| banana    | 1.2.2 |

При помощи инструкции `LIKE` в SQL мы можем найти всех потомков какого-либо узла. Как и вложенные множества, такой паттерн рекомендуется применять для почти неизменяемых деревьев


## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-4.-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0-postgresql"></a> Лекция 4. Архитектура PostgreSQL

### <a name="postmaster"></a> Postmaster

При запуске PostgreSQL сервере первым делом создается процесс Postmaster. **Postmaster** - главный процесс, который принимает входящие подключения от клиентов, управляет созданием и завершением дочерних процессов

Для каждого нового подключения Postmaster порождает отдельный процесс, который обрабатывает SQL-запросы, выполняет планирование и возвращает результаты клиенту. Такой подход изолирует сессии и повышает стабильность системы

### <a name="%D1%84%D0%BE%D0%BD%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B-%28background-workers%29"></a> Фоновые процессы (Background Workers)

PostgreSQL использует дополнительные фоновые процессы для выполнения служебных задач:

* **Checkpointer** периодически сбрасывает измененные данные из общей памяти (shared buffers) на диск. Это снижает время на восстановление после сбоев и оптимизирует запись: данные сначала попадают в буфер, а затем периодически записываются на диск

* **WAL Writer** обеспечивает запись журналов предзаписи (Write-Ahead Logging, WAL), что гарантирует, что изменения сначала фиксируются в журнале, прежде чем быть записанными на диск. WAL Writer используется для обеспечения надежности и возможности восстановления

* **Background Writer** фоново записывает изменённые страницы из буферного кэша на диск, помогая поддерживать актуальность данных и снижать пик нагрузок при массовых запросах

* **Stats Collector** собирает статистику, ведёт учет выполнения запросов, использования ресурсов и другой информации, необходимой для работы планировщика запросов и оптимизации системы

* **Autovacuum** - процесс очистки (об этом далее)

### <a name="%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C%D1%8E-%D0%B8-%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85"></a> Работа с памятью и хранением данных

PostgreSQL выделяет область общей памяти, используемую для:
  
* Хранения буферов данных (shared buffers)
* Управления системными блокировками
* Отслеживания состояния транзакций
* Хранения WAL-буферов

Данные хранятся в виде файлов на диске. Для взаимодействия с хранилищем данных используются специализированные модули доступа и загрузчик данных

### <a name="%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-sql-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2"></a> Обработка SQL-запросов

PostgreSQL обрабатывает запросы так:

1. **Прием запроса**. Запрос поступает через клиент к дочернему процессу, созданному Postmaster

2. **Парсинг**. SQL-текст разбивается на токены и строится синтаксическое дерево. Здесь производится проверка на ошибки 

3. **Рерайтинг**. Запрос преобразуется с учетом представлений, правил и триггеров

4. **Планирование и оптимизация**. Планировщик запросов анализирует различные стратегии выполнения, используя собранную статистику, и выбирает наиболее оптимальный план

5. **Исполнение**. Выполнение плана запроса: данные извлекаются, обрабатываются через узлы (фильтрация, сортировка, соединения и т.д.) и формируется результат

6. **Возврат результатов**. После выполнения запроса результаты возвращаются клиенту. Для операций, изменяющий данные, делается коммит изменений
   
### <a name="mvcc"></a> MVCC

PostgreSQL реализует механизм MVCC (multiversion concurrency control, многоверсионный контроль согласованности), позволяющий обеспечить согласованность данных при одновременном доступе множества пользователей

Внутри себя PostgreSQL хранит счетчик транзакций, который можно получить функцией `txid_current()`. При выполнении транзакции этот счетчик увеличивается. Каждая запись в отношении имеет системные атрибуты `xmin` и `xmax`

* Когда запись создается, ей присваивается значение счетчика в поле `xmin`
* Когда запись удаляется, она не удаляется, а просто присваивается значение счетчика в ее поле `xmax`
* Когда запись изменяется, на самом деле создается ее копия с изменными атрибутами, старой записи присваивается значение счетчика в поле `xmax`, а новой присваивается в поле `xmin`

Таким образом, эти атрибуты задают жизненный цикл каждого снимка каждой записи, чтобы соблюдать целостность данных.  
Помимо них есть еще `cmin` и `cmax`. Они обозначают жизненный цикл самой записи и не затрагиваются при обновлении записи

### <a name="vacuum-%D0%B8-autovacuum"></a> Vacuum и Autovacuum

Так как MVCC требует очень много памяти на диске, нужны инструменты, очищающие неактуальные данные. В PostgreSQL есть:

* **Vacuum** - команда для очистки базы данных, которая удаляет "мертвые" строки (устаревшие версии записей, помеченные как удаленные) и сбрасывает счетчик транзакций, участвующий в механизме MVCC, тем самым предотвращая его переполнение

* **Autovacuum** - автоматическая версия процесса очистки, которая определяет необходимость очистки таблиц на основании внутренней статистики и автоматически запускает процесс Vacuum для удаления устаревших данных и реорганизации таблиц, что помогает поддерживать оптимальную производительность базы данных



## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-5.-%D0%B2%D1%81%D1%82%D1%80%D0%B5%D1%87%D0%B0-%D1%81-%D0%BE%D0%BB%D0%B5%D0%B3%D0%BE%D0%BC-%D1%81%D0%B5%D1%80%D0%B3%D0%B5%D0%B5%D0%B2%D0%B8%D1%87%D0%B5%D0%BC-%D0%B1%D0%B0%D1%80%D1%82%D1%83%D0%BD%D0%BE%D0%B2%D1%8B%D0%BC"></a> Лекция 5. Встреча с Олегом Сергеевичем Бартуновым

_Вместо этой лекции была встреча с Олегом Сергеевичем Бартуновым, сооснователем компании Postgres Professional, развивающей форк PostgreSQL для enterprise-решений. Здесь же представлено краткое содержание того, что на ней было - крайне рекомендуется послушать все самим_

[Часть 1](https://github.com/user-attachments/assets/09e264f8-1360-4fdc-85ad-c5ef61c7b858)

[Часть 2](https://github.com/user-attachments/assets/0bf6b561-4110-471c-937c-4cd256c42e7e)

[Часть 3](https://github.com/user-attachments/assets/f27d6250-e56f-40c5-ba9c-29db9311767a)

[Часть 4](https://github.com/user-attachments/assets/59f662e4-25d2-4a29-9bcd-98a51441ee56)

[Часть 5](https://github.com/user-attachments/assets/06a7db5e-6821-4855-8996-3ebba50dc041)

[Часть 6](https://github.com/user-attachments/assets/85a47574-d555-4f41-afe7-62232f7b8a37)

---

Первые данные появились, когда человек захотел с кем-то пообщаться или что-то сохранить. Например, астрономия. Астрономические наблюдения требуют больших объемов хранения данных

Сначала примитивными базам данных были шумерские таблички для учета казны и налогом, потом появились каталоги по авторам в библиотеках. Файлы стали первой попыткой организовать данные

Первой настоящей базой данных стала IMS (Information Management System, другое название DB1). IBM создала ее по тендера для ракеты Saturn V. Она была иерархической и хранила в себе состояние компонентов ракеты

После этого Кодд выпускает свою статью о реляционной модели данных и реляционной алгебре. После этого, Дональд Чемберлин и Рэймонд Бойс создают язык SEQUEL, который изменит свое название на SQL

В период с 75-ого по 82-ой создаются прототипы реляционной СУБД System R (или же DB2)

До этого, узнав о статье Кодда, ученые из университета Беркли Майкл Стоунбрейкер и Юджин Вонг создают свою СУБД под названием Ingres (Interactive Graphics Retrieval System)

Намного позднее Стоунбрейкер с 1986 по 1994 создает реляционную СУБД Postgres (производное от Post Ingres). Postgres изначально распространялся с открытым исходным кодом. Изначальный язык запрос POSTQUEL был заменен на SQL - с тех пор она стала называться PostgreSQL

Олег Бартунов начал вносить вклад в код PostgreSQL в 1995 году. С тех пор благодаря ему и другим разработчикам из России PostgreSQL обзавелся интернационализацией, поддержкой локалей, полнотекстовым поиском, jsonb. В частности благодаря Вадиму Михееву в PostgreSQL появился WAL, MVCC, vacuum и другие фичи

Сейчас же компания Postgres Professional является вторым вкладчиком в мире в кодовую базу PostgreSQL



