## Тестирование

Тестирование ПО - один из важнейших этапов разработки, целью которого - убедиться в том, что наша программа успешно работает, не имеет ошибок и багов, а также соответствует заявленной планке качества

Тестирование нужно по разным причинам: проще и дешевле проверить во время разработки, что что-то не работает, нежели выслушивать недовольство заказчика и терпеть репутационные риски

Тестирование осуществляется разным методами и на разных этапах. Глобально всякую кодовую базу (хорошо написанную) можно разделить на функциональные модули. Далее тесты можно разделить на уровни проверки этих модулей:

* Модульные тесты (Unit-тесты) проверяют работоспособность отдельных модулей, в том числе методы, функции, классы

    Модульные тесты пишутся непосредственно разработчиками во время написания соответствующего модуля и на соответствующем языке. Подход Test-Driven Development (TDD) предполагает создание тестов до написания модуля, чтобы сразу определить поведение модуля

    Например, на языке Java фреймворк JUnit обладает достаточно мощным инструментарием

    Помимо этого, если тестируемая функция (или класс) требует какую-то зависимость в виде другой функции, применяют заглушки (или моки, mock), которые обладают заданным поведением для конкретного теста

* Интеграционные тесты проверяют корректность взаимодействия и интеграции компонентов системы между собой или с внешними сервисами

    Интеграционные тесты создаются разработчиками или тестировщиками, и в них проверяются реальные критически важные зависимости, такие как работа с настоящей базой данных или получение HTTP-запросов

    Эти тесты проверяют контракты между компонентами. Они медленнее модульных тестов, потому что требуют запуск внешних сервисов

* Контрактные тесты (или API-тесты) проверяют корректность работы программных интерфейсов. Они тестируют бизнес-логику через публичные контракты, не затрагивая пользовательский интерфейс

* Системные тесты (End-to-end или E2E тесты) проверяют, что вся система в сборе работает корректно и бизнес-сценарий выполняется от начала до конца

    Такие тесты обычно пишут тестировщики

    E2E-тесты хрупкие, так как малейшее изменение пользовательского интерфейса может их сломать, а также требуют полного развертывания системы (продакшн-подобного окружения)

* Приемочное тестирование позволяет проверить финальный продукт

    Приемочное тестирование выполняется вручную тестировщиками или заказчиками непосредственно, поэтому это самые долгие и дорогие тесты

Эти уровни образуют "пирамиду тестов". Ближе к вершине количество тестов становится меньше, но сами они становятся дороже и дольше:

![Пирамида тестов]()

Помимо уровней тестирования, существуют различные виды тестирования, сфокусированные на конкретных аспектах качества:

* Нагрузочное или стрессовое тестирование проверяет, как система отрабатывает в условиях повышенной нагрузки. Тут измеряют время отклика, пропускную способность и стабильность системы

* Тесты безопасности проверяет продукт на наличие уязвимостей, например, с помощью SQL-инъекций, небезопасных настроек и так далее

* Тестирование удобства использования

* Тестирование совместимости проверяет работу в разных средах, браузерах, операционных системах


---

Главное помнить:

* Тестирование показывает наличие дефектов, но не может доказать их отсутствие. Поэтому исчерпывающее тестирование невозможно: нельзя доказать, что функция, принимающая три 32-битных целых числа, корректно работает, так как это потребовало бы проверки `2^96` (`7.9 * 10^28`) комбинаций, что физически невозможно

* Раннее тестирование экономит время и деньги

* Кластеризация дефектов: большинство ошибок в программном продукте сосредоточены в небольшом количестве его модулей. Связано это со сложностью реализации модуля, его частыми изменениями или плохо задокументированным легаси-кодом

* "Парадокс пестицида": если набор тестов долгое время не обновляется и не дополняется новыми сценариями, он со временем теряет эффективность в поиске новых дефектов

* Контекст применения продукта: принципы тестирования мобильной игры и медицинского ПО, очевидно, отличаются, поэтому нет универсального подхода
