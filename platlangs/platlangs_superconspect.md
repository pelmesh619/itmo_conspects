# <a name="%D0%BF%D0%BB%D0%B0%D1%82%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%B8-%D1%81%D1%80%D0%B5%D0%B4%D1%8B-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F"></a> Платформы и среды выполнения языков программирования


* [Платформы и среды выполнения языков программирования](#%D0%BF%D0%BB%D0%B0%D1%82%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%B8-%D1%81%D1%80%D0%B5%D0%B4%D1%8B-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
  * [Лекция 1. Введение в компиляторы и виртуальные машины](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-1.-%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D1%8B-%D0%B8-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D1%8B)
  * [Лекция 2. История, цели и сложности](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-2.-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F%2C-%D1%86%D0%B5%D0%BB%D0%B8-%D0%B8-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8)
  * [Лекция 3. Требования и решения](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-3.-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F)



На курсе будут рассматриваться

* дизайн языков программирования, какие сложности возникают
* как запускать свои языки поверх виртуальной машины
* как компилировать языки программирования, какие оптимизации применяются
* что такое интерпретатор, байт-код
* как работает система типов, сборщик мусора
* чем отличаются JIT-компиляция и AOT-компиляция

## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-1.-%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D1%8B-%D0%B8-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D1%8B"></a> Лекция 1. Введение в компиляторы и виртуальные машины

<!-- Лектор - Гаврин Е. А. -->

Разработку ПО можно разделить на две части:

* разработка прикладного ПО: офисное ПО, игры, научное ПО, финансовое ПО и так далее
* разработка системного ПО: базы данных, операционные системы, компилятор и так далее

Существенной проблемой при разработке является трудность управления памятью в так называемых неуправляемых языках (например, C и C++). Поэтому появились

* языки с безопасной работой с памятью (memory-safe), которые обнаруживают проблемы на этапе компиляции, такие как Rust
* санитайзеры - инструменты для обнаружения проблем с памятью и не только во время выполнения программы, которые используют специально инструментированную компиляцию

Позже в 90-ых начали появляться управляемые языки: Java, C#, JavaScript. Как следствие появились виртуальные машины, которые управляли памятью и исполняли байт-код

Теперь условно можно выделить два типа языков:

* со статическим компилятором, как C, C++
* с интерпретатором или виртуальной машиной, как Java, C#

Каждый язык соответствовал одной из этих целей:

* язык, программы на котором работают быстро, а время компиляции и запуска нам неважно
* язык, где не нужна пиковая производительность, но важен быстрый запуск, например, JavaScript


В компиляторе берется исходный код, он представляется в виде промежуточных структур, таких как абстрактное синтаксическое дерево (Abstract Syntax Tree, AST) и граф потока управления (Control Flow Graph, CFG), а потом превращается в нативный для процессора/ОС код, который исполняется процессором

Термин AOT-компиляция (Ahead-of-Time) предполагает, что код обрабатывается до непосредственного выполнения. Напротив, JIT-компиляция (Just-in-Time) - это компиляция байт-кода в машинный код прямо во время выполнения программы. Это позволяет применять оптимизации на основе данных о реальном выполнении программы (профилирование)

В случае с виртуальной машиной исходный код превращается в промежуточный код, которой после исполняется виртуальной машиной

---

За последние два десятка лет очень изменилось то, как мы используем наши устройства - сейчас мы работаем с большой комбинацией устройств, и это создает множество совместных сценариев работы с устройствами

В индустрии стремятся сделать так, чтобы приложения разрабатывались под разные устройства

Так как бизнес хочет наилучшее решение за наименьшие деньги и время, нужно, чтобы устройства имели одну кодовую базу. Для запуска приложения на разных устройствах нужны виртуальные машины, фреймворки и библиотеки, реализованные для каждой из целевых платформ

Оказывается, что количество выручки с продаж потребительской электроники растет, а люди ценят наличие экосистемы среди своих устройств

Из-за возникшей дуополии Google и Apple это кажется простой задачей, однако существует огромное количество производителей, которые имеют свои маркеты приложений (около 400). С пользовательской точки зрения, когда на рынке 400 маркетов, становится больно пользоваться экосистемами

Появилась альтернатива - миниприложения. Такие миниприложения, написанные на JavaScript, встроены в мессенджер WeChat. Оказалось, что миниприложения начали преобладать над этими 400 маркетами, так как они были намного удобнее

Для разработчика мобильных приложений это означает:

* разработать две версии приложения: одно для Android, одно для iOS
* загрузить как минимум в несколько магазинов приложений: для России - это как минимум 3 (Google Play, AppStore, RuStore), для Китая - 8
* поддерживать версии для разных платформ и соблюдать все правила и процедуры разных маркетов

Маленькому бизнесу становится дорого это поддерживать, поэтому нам нужен инструмент, который позволит решить эту проблему более эффективно. Проще всего сделать одну виртуальную машину под разные устройства

Многие производители телефонов в первую очередь зарабатывают с продажи аппаратного обеспечения. Они имеют широкую линейку продуктов и данные использования от реальных пользователей. 

Разработчикам приложений важно минимизировать усилия на разработку приложений, поэтому для их привлечения нужна знакомая экосистема разработки и простой доступ к заработку

А пользователям важно, чтобы приложения были быстрыми, а батарея держалась долго, поэтому нужно, чтобы приложения были мгновенными, энергоэффективными и работали внутри экосистемы устройств

Не всегда разработка кроссплатформенных решений облегчает создание новых продуктов, например Oracle с агрессивным лицензированием Java и появившийся в ответ на это C#. Потребность в большинстве языках программирования появилась с ростом рынка потребительской электроники, такие как Go, Swift, Kotlin, Dart. Например, Kotlin появился как ответ на медленные обновления языка Java. Swift - как современная альтернатива Objective-C. React - как попытка сделать кроссплатформенное решение для JavaScript

Кроссплатформенные решения поддерживаются ограниченным набором компании (Google, Apple, Microsoft и так далее). Такие компании заинтересованы, потому что они получают основную выгоду

<!-- Первое, что выбирается при разработке приложения - фреймворк для интерфейса. Современный фреймворк для интерфейса должен поддерживать множество платформ, а также фреймворк должен быть основан на кроссплатформенном языке программирования, обеспечивая консистентность среди устройств -->

Разберем примеры кроссплатформенных решений:

* Платформа .NET и фреймворк Xamarin как единая кодовая база для разработки

* Для Android виртуальная машина Dalvik (позже Android Runtime, ART). Изначально Dalvik был простым интерпретатором. Позже в него добавили JIT- и AOT-компиляцию. Далее сборка профилей использования кода позволила компилировать приложения на серверной инфраструктуре

* Для браузеров есть виртуальная машина (например, V8 для JavaScript), пользовательский интерфейс и движок для рендера

* LLVM - платформа для построения компиляторов. Она предоставляет универсальное промежуточное представление (Intermediate Representation, IR), на котором проводятся оптимизации, и бэкенды для генерации машинного кода под разные архитектуры. Например, на основе LLVM разработан компилятор Clang для C/C++



## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-2.-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F%2C-%D1%86%D0%B5%D0%BB%D0%B8-%D0%B8-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8"></a> Лекция 2. История, цели и сложности

<!-- Лектор - Недоря А. Е. -->

Разработка языков программирования началась с создания языка для машины ЭНИАК (ENIAC, Electronic Numerical Integrator and Computer)

Программирование на ЭНИАК осуществлялось соединением нужных разъемов на панели проводами и зачастую занимало недели

ЭНИАК использовалась для расчета вычисления, связанных с ядерным оружием, прогнозирования погоды, инженерных расчетов

Первым широкоиспользуемым языком стал FORTRAN, созданный в 1950-ых Джоном Бэкусом в IBM. Далее в 1956-1958 создается LISP при участии Джона Маккарти

Большинство популярных языков, таких как Go, Rust, Typescript, Kotlin, используемых в индустрии, были разработаны в течение нескольких лет (4-6 лет), что подтверждает, что создание промышленного языка программирования - задача нетривиальная


Целями создания языка программирования могут быть разными. Например, 

* C# был создан, чтобы избежать юридических проблем
* Swift и Kotlin как замена устаревших языков Objective-C и Java
* Go и Rust как удовлетворение высоких требований по безопасности и производительности

Поэтому у конкретного языка может быть ограниченная область применения

Так что же нужно для создания языка:

* Документация языка, а именно спецификация, описание грамматики, документация стандартной библиотеки, туториалы
* Тесты для проверки компилятора соответствии спецификации
* Компилятор, умеющий генерировать код для разных архитектур и ОС
* Стандартная библиотека
* Поддержка выполнения кода (управление памятью и параллелизмом)
* Среда разработки, инструменты для дебага
* JIT-компилятор
* Пакетный менеджер
* Модели памяти, параллелизма
* Непротиворечивость системы типов, гарантии (например, что не бывает утечки памяти)

Разработка языка программирования - огромная работа, которая может не прекращаться. Разработка начинается с формулировки требований и приоритетов:

* Важнее скорость программы или продуктивность разработчика?
* Важнее надежность и безопасность или другие характеристики?
* Каков будет способ управления и виды параллелизма?
* Каков будет синтаксис, статическая и динамическая семантики?

Также нужно выбрать:

* компромисс между эффективностью, продуктивностью, безопасностью и переносимостью
* эволюцию (что-то лучшее) или революцию
* динамическая система типов или статическая
* управление памятью: ручное, сборщик мусора, подсчет ссылок, владение и заимствование
* управление параллелизмом через потоки или корутины
* экосистема: создать новую или приспособиться к существующей

Что бы разработчик не выбрал, кому-то это можно не понравится. Нельзя уверенно сказать, какая комбинация решений приведет к наилучшему исходу без прототипирования, а функции языка могут взаимодействовать друг с другом

Пример взаимодействия функций языка из языка Go:

```go
package main

import "fmt"

type IM interface {
    Method()
}

type SM struct {i int}

fune (x *SM) Method() {
    x.i = 1
}

func check(im IM) {
    if im != nil {
        im.Method()
    }
    fmt.Println("checked")
}
    
func main() {
    check(nil) // checked

    var S_nil *SM = nil
    check(S_nil) // segfault
}
```

Здесь функция `check` правильно обработает значение `nil`, однако при передачи указателя на объект `SM` интерфейса `IM`, равного `nil`, выбрасывается ошибка доступа к адресу, так как по адресу `nil` нет объекта с методом `Method()`


## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-3.-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F"></a> Лекция 3. Требования и решения

<!-- Лектор - Недоря А. Е. -->
  
Современная система программирования или приложение содержит компоненты, написанные на нескольких языках, так как ни один язык не удовлетворяет все потребности. Части системы, такие как бизнес-логика, фреймворки, UI, требуют разных языков, которые отличаются в управлении памятью, параллелизмом, системе типом и так далее

Тогда появилась идея создания семейства языков, которые будут хорошо вместе взаимодействовать, вместо языка, который будет встраиваться с другими

Тогда для этих языков нужно писать компилятор, значит, нужно выбрать язык, на котором нужно написать этот компилятор

При этом, в нашем семействе должен быть язык, на котором будет приятно писать следующие версии нашего компилятора, чтобы снизить зависимость и влияние от сторонних языков

В начале этот первый язык должен быть легко читаемым, легко понимаемым, иметь все нужные простые функции и механизмы и ничего того, что выходит за нашу область. Также в нем должно быть уменьшено число ошибок времени исполнения, безопасность null-типов, системы типов, сборщик мусора и модульность

Производительность первого языка не должна быть приоритетной для нас

Название языка должно быть простым для понимания. После этого можно начать предварительный дизайн: дизайн грамматики и система типов

Шаг второй - разработка компилятора на другом языке и исполнения скомпилированного кода. Далее компилятор пишется на самом языке, что позволяет протестировать наш язык в прикладной задаче

Грамматика и синтаксис языка должна быть простой, а семантика - очевидной, не должно быть скрытой семантики и "злой магии"

Среди базовых типов можно выбрать байт (8-битное целое число), 64-битное целое число, 64-битное вещественное число, логический тип, символ, строка. Для создания компилятора могут также понадобиться вектор (динамический массив), опциональный тип (вместо null) и классы 

Другие продвинутые механизмы могут вызвать дополнительные трудности в разработке:

* Цикл `foreach` может потребовать другие функции, такие как итераторы и кортежи
* ООП добавляет дополнительно семантики для конструкторов, а безопасность сложно достичь
* Шаблонные типы добавляют сложности в семантике и тяжело реализуемы



