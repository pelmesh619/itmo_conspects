# <a name="%D0%BF%D0%BB%D0%B0%D1%82%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%B8-%D1%81%D1%80%D0%B5%D0%B4%D1%8B-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F"></a> Платформы и среды выполнения языков программирования


* [Платформы и среды выполнения языков программирования](#%D0%BF%D0%BB%D0%B0%D1%82%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%B8-%D1%81%D1%80%D0%B5%D0%B4%D1%8B-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
  * [Лекция 2. История, цели и сложности](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-2.-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F%2C-%D1%86%D0%B5%D0%BB%D0%B8-%D0%B8-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8)
  * [Лекция 3. Требования и решения](#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-3.-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F)



## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-2.-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F%2C-%D1%86%D0%B5%D0%BB%D0%B8-%D0%B8-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8"></a> Лекция 2. История, цели и сложности

<!-- Лектор - Недоря А. Е. -->

Разработка языков программирования началась с создания языка для машины ЭНИАК (ENIAC, Electronic Numerical Integrator and Computer)

Программирование на ЭНИАК осуществлялось соединением нужных разъемов на панели проводами и зачастую занимало недели

ЭНИАК использовалась для расчета вычисления, связанных с ядерным оружием, прогнозирования погоды, инженерных расчетов

Первым широкоиспользуемым языком стал FORTRAN, созданный в 1950-ых Джоном Бэкусом в IBM. Далее в 1956-1958 создается LISP при участии Джона Маккарти

Большинство популярных языков, таких как Go, Rust, Typescript, Kotlin, используемых в индустрии, были разработаны в течение нескольких лет (4-6 лет), что подтверждает, что создание промышленного языка программирования - задача нетривиальная


Целями создания языка программирования могут быть разными. Например, 

* C# был создан, чтобы избежать юридических проблем
* Swift и Kotlin как замена устаревших языков Objective-C и Java
* Go и Rust как удовлетворение высоких требований по безопасности и производительности

Поэтому у конкретного языка может быть ограниченная область применения

Так что же нужно для создания языка:

* Документация языка, а именно спецификация, описание грамматики, документация стандартной библиотеки, туториалы
* Тесты для проверки компилятора соответствии спецификации
* Компилятор, умеющий генерировать код для разных архитектур и ОС
* Стандартная библиотека
* Поддержка выполнения кода (управление памятью и параллелизмом)
* Среда разработки, инструменты для дебага
* JIT-компилятор
* Пакетный менеджер
* Модели памяти, параллелизма
* Непротиворечивость системы типов, гарантии (например, что не бывает утечки памяти)

Разработка языка программирования - огромная работа, которая может не прекращаться. Разработка начинается с формулировки требований и приоритетов:

* Важнее скорость программы или продуктивность разработчика?
* Важнее надежность и безопасность или другие характеристики?
* Каков будет способ управления и виды параллелизма?
* Каков будет синтаксис, статическая и динамическая семантики?

Также нужно выбрать:

* компромисс между эффективностью, продуктивностью, безопасностью и переносимостью
* эволюцию (что-то лучшее) или революцию
* динамическая система типов или статическая
* управление памятью: ручное, сборщик мусора, подсчет ссылок, владение и заимствование
* управление параллелизмом через потоки или корутины
* экосистема: создать новую или приспособиться к существующей

Что бы разработчик не выбрал, кому-то это можно не понравится. Нельзя уверенно сказать, какая комбинация решений приведет к наилучшему исходу без прототипирования, а функции языка могут взаимодействовать друг с другом

Пример взаимодействия функций языка из языка Go:

```go
package main

import "fmt"

type IM interface {
    Method()
}

type SM struct {i int}

fune (x *SM) Method() {
    x.i = 1
}

func check(im IM) {
    if im != nil {
        im.Method()
    }
    fmt.Println("checked")
}
    
func main() {
    check(nil) // checked

    var S_nil *SM = nil
    check(S_nil) // segfault
}
```

Здесь функция `check` правильно обработает значение `nil`, однако при передачи указателя на объект `SM` интерфейса `IM`, равного `nil`, выбрасывается ошибка доступа к адресу, так как по адресу `nil` нет объекта с методом `Method()`


## <a name="%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-3.-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F"></a> Лекция 3. Требования и решения

<!-- Лектор - Недоря А. Е. -->
  
Современная система программирования или приложение содержит компоненты, написанные на нескольких языках, так как ни один язык не удовлетворяет все потребности. Части системы, такие как бизнес-логика, фреймворки, UI, требуют разных языков, которые отличаются в управлении памятью, параллелизмом, системе типом и так далее

Тогда появилась идея создания семейства языков, которые будут хорошо вместе взаимодействовать, вместо языка, который будет встраиваться с другими

Тогда для этих языков нужно писать компилятор, значит, нужно выбрать язык, на котором нужно написать этот компилятор

При этом, в нашем семействе должен быть язык, на котором будет приятно писать следующие версии нашего компилятора, чтобы снизить зависимость и влияние от сторонних языков

В начале этот первый язык должен быть легко читаемым, легко понимаемым, иметь все нужные простые функции и механизмы и ничего того, что выходит за нашу область. Также в нем должно быть уменьшено число ошибок времени исполнения, безопасность null-типов, системы типов, сборщик мусора и модульность

Производительность первого языка не должна быть приоритетной для нас

Название языка должно быть простым для понимания. После этого можно начать предварительный дизайн: дизайн грамматики и система типов

Шаг второй - разработка компилятора на другом языке и исполнения скомпилированного кода. Далее компилятор пишется на самом языке, что позволяет протестировать наш язык в прикладной задаче

Грамматика и синтаксис языка должна быть простой, а семантика - очевидной, не должно быть скрытой семантики и "злой магии"

Среди базовых типов можно выбрать байт (8-битное целое число), 64-битное целое число, 64-битное вещественное число, логический тип, символ, строка. Для создания компилятора могут также понадобиться вектор (динамический массив), опциональный тип (вместо null) и классы 

Другие продвинутые механизмы могут вызвать дополнительные трудности в разработке:

* Цикл `foreach` может потребовать другие функции, такие как итераторы и кортежи
* ООП добавляет дополнительно семантики для конструкторов, а безопасность сложно достичь
* Шаблонные типы добавляют сложности в семантике и тяжело реализуемы



