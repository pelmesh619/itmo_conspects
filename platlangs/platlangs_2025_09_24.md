## Лекция 3. Требования и решения

<!-- Лектор - Недоря А. Е. -->
  
Современная система программирования или приложение содержит компоненты, написанные на нескольких языках, так как ни один язык не удовлетворяет все потребности. Части системы, такие как бизнес-логика, фреймворки, UI, требуют разных языков, которые отличаются в управлении памятью, параллелизмом, системе типом и так далее

Тогда появилась идея создания семейства языков, которые будут хорошо вместе взаимодействовать, вместо языка, который будет встраиваться с другими

Тогда для этих языков нужно писать компилятор, значит, нужно выбрать язык, на котором нужно написать этот компилятор

При этом, в нашем семействе должен быть язык, на котором будет приятно писать следующие версии нашего компилятора, чтобы снизить зависимость и влияние от сторонних языков

В начале этот первый язык должен быть легко читаемым, легко понимаемым, иметь все нужные простые функции и механизмы и ничего того, что выходит за нашу область. Также в нем должно быть уменьшено число ошибок времени исполнения, безопасность null-типов, системы типов, сборщик мусора и модульность

Производительность первого языка не должна быть приоритетной для нас

Название языка должно быть простым для понимания. После этого можно начать предварительный дизайн: дизайн грамматики и система типов

Шаг второй - разработка компилятора на другом языке и исполнения скомпилированного кода. Далее компилятор пишется на самом языке, что позволяет протестировать наш язык в прикладной задаче

Грамматика и синтаксис языка должна быть простой, а семантика - очевидной, не должно быть скрытой семантики и "злой магии"

Среди базовых типов можно выбрать байт (8-битное целое число), 64-битное целое число, 64-битное вещественное число, логический тип, символ, строка. Для создания компилятора могут также понадобиться вектор (динамический массив), опциональный тип (вместо null) и классы 

Другие продвинутые механизмы могут вызвать дополнительные трудности в разработке:

* Цикл `foreach` может потребовать другие функции, такие как итераторы и кортежи
* ООП добавляет дополнительно семантики для конструкторов, а безопасность сложно достичь
* Шаблонные типы добавляют сложности в семантике и тяжело реализуемы

