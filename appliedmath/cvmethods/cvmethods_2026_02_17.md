<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
<script>
window.MathJax = {
  tex: {
    inlineMath: {'[+]': [['$', '$']]}
  }
};
</script>

## Лекция 2. Обработка изображений

Помимо RGB-модели, где цвет пикселя кодируется используют и другие цветовые пространства:

* HSV (Hue, Saturation, Value или Brightness) - Тон, Насыщенность, Значение (или Яркость)
* HSL (Hue, Saturation, Lightness) - Тон, Насыщенность, Светлота

Если модель RGB представить как куб, где оси определяют значения в красном, зеленом и синем каналах, то этот куб можно деформировать так, что бы получить цилиндры, представляющие модели HSV и HSL

![HSL и HSV](./images/cvmethods_hsv_hsl.png)

Алгебраически преобразования из RBG в HSL и HSV выглядят так:

1. Вычисляются максимум, минимум и диапазон значений RBG:

    $M = \max(R, G, B)$

    $m = \min(R, G, B)$

    $C = \mathrm{range}(R, G, B) = M - m$

2. Тон вычисляется так:

    $$H^\prime = \begin{cases}
        \text{не определено} & \text{если } C = 0 \\
        \frac{G - B}{C} \ \mathrm{mod} \ 6 & \text{если } M = R \\
        \frac{B - R}{C} + 2 & \text{если } M = G \\ 
        \frac{R - G}{C} + 4 & \text{если } M = B \end{cases}$$

    $$H = 60^\circ \cdot H^\prime$$

    Как можно заметить, тон - это угол между лучами из центра цилиндра, направленным к красному цвету (#FF0000) и целевому цвету

3. Светлота находится как среднее в интервале: $L = \mathrm{mid}(R, G, B) = \frac{1}{2} (M + m)$

4. Значение определяется как максимум: $V = \max(R, G, B) = M$

5. Насыщенность вычисляется так:

    $$S_V = \begin{cases}0 & \text{если } V = 0 \\ \frac{C}{V} & \text{в других случаях}\end{cases}$$

    $$S_L = \begin{cases}0 & \text{если } L = 1 \text{ или } L = 0 \\ \frac{C}{1 - \vert 2L - 1 \vert} & \text{в других случаях}\end{cases}$$

Также некоторые модели вместо значения и светлоты используют:

* Интенсивность (Intensity) - $I = \mathrm{avg}(R, G, B) = \frac{1}{3} (R + G + B)$

* Яркость (Luma), которая вычисляется как взвешенное среднее

    В разных стандартах сектора радиосвязи Международного союза электросвязи (ITU-R) применяют разные веса. Так для телевидения высокой четкости (HDTV, 1080p) применяют $Y^\prime_{709} = 0.2126R + 0.7152G + 0.0722B$, а для телевидения сверхвысокой четкости (UHDTV, то есть 4K и 8K) и с расширенным динамическим диапазоном (HDR) используют $Y^\prime_{2020} = 0.2627 R + 0.6780 G + 0.0593 B$

---

Теперь рассмотрим базовые алгоритмы обработки изображений:

* Смешивание (Blending) - алгоритм, позволяющий смешать два изображения в одно

    В тривиальное случае смешивание - это среднее взвешенное значений двух пикселей изображения:

    ![Смешивание](./images/cvmethods_blending.png)

    Вес пикселя первого изображения обозначается $\alpha$. Значение конечного пикселя вычисляется как $\mathrm{dst}(x, y) = \alpha \cdot \mathrm{src}_1 (x, y) + (1 + \alpha) \cdot \mathrm{src}_2 (x, y)$, где $\mathrm{src}_1 (x, y)$ - значение пикселя на первой картинке, а $\mathrm{src}_2 (x, y)$ - на второй

    В более усложненном алгоритме значение конечного пикселя выглядит так: $\mathrm{dst}(x, y) = \alpha \cdot \mathrm{src}_1 (x, y) + \beta \cdot \mathrm{src}_2 (x, y) + \gamma$, где $\alpha, \beta$ - веса, а $\gamma$ - смещение

    Смешивание полезно, чтобы добавить водяной знак на изображение. Обычно водяной знак изображается на белом фоне, который можно убрать с помощью маски:

    ![Смешивание с маской](./images/cvmethods_blending_mask.png)

    > Код примера: [cvmethods_blending.py](./examples/cvmethods_blending.py)

* Пороговая обработка (Image Thresholding) - алгоритм, который преобразует пиксели исходного изображения, значения которых проходят порог $T$, в один цвет, а те, которые не проходят порог $T$, в другой:

    $\mathrm{dst}(x, y) = \mathrm{src}(x + i, y + j) \cdot I(\mathrm{src}(x + i, y + j) \geq T)$ (здесь $I(x)$ - индикатор, равный 1, если выражение $x$ верно, иначе 0)

    Порог может быть глобальным для всех сегментов изображения, но если на изображении яркость меняется (например, есть тень), то глобальный порог работает плохо

    Чтобы исправить это, используют адаптивный порог. Есть два популярных подхода:

    * Средняя пороговая обработка. В нем порог равен среднему от соседних в окне $k \times k$ пикселях

        $\mathrm{dst}(x, y) = \frac{1}{(2k + 1)(2k + 1)} \sum_{i = -k}^k \sum_{j = -k}^k \mathrm{src}(x + i, y + j)$

    * Гауссовская пороговая обработка. Здесь значение пикселя взвешивается относительно того, насколько он далеко от целевого, с помощью функции Гаусса: $\displaystyle G(x, y) = \frac{1}{2\pi \sigma^2} e^{-\frac{x^2 + y^2}{2 \sigma^2}}$

        $\mathrm{dst}(x, y) = \frac{1}{(2k + 1)(2k + 1)} \sum_{i = -k}^k \sum_{j = -k}^k \mathrm{src}(x + i, y + j) G(i, j)$

    ![Пороговая обработка](./images/cvmethods_thresholding.png)

    > Код примера: [cvmethods_thresholding.py](./examples/cvmethods_thresholding.py)

* Размытие (Blurring) - обработка изображения так, что число деталей уменьшается, но при этом не теряется общая структура изображения

    Сейчас самый распространенный алгоритм - это гауссовское размытие, который использует функцию Гаусса

    С помощью окна свертки выбранного размера $k \times k$ вычисляется значение конечного пикселя: $\displaystyle \mathrm{dst}(x, y) = \sum_{i = -k}^k \sum_{j = -k}^k G(i, j) \mathrm{src}(x + i, y + j)$

    ![Размытие](./images/cvmethods_blur.png)

    > Код примера: [cvmethods_blur.py](./examples/cvmethods_blur.py)

* Градиент (Gradient)

    Градиент позволяет обнаруживать резкие переходы цветов на картинке. Выходное изображение показывает светлые пиксели там, где значение пикселей исходного изображения меняются сильно

    Градиент определяется аналогично, как и в матанализе: $\nabla f = \begin{pmatrix}\frac{\partial f}{\partial x} \\ \frac{\partial f}{\partial y}\end{pmatrix}$ - направление наискорейшего роста

    Вместо градиентов используют приближение в виде операторов Собеля: для градиента по оси $Ox$ - $\begin{pmatrix}-1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1\end{pmatrix}$, для градиента по оси $Oy$ - $\begin{pmatrix}-1 & -2 & -1 \\ 0 & 0 & 0 \\ 1 & 2 & 1\end{pmatrix}$

    ![Градиент](./images/cvmethods_gradient.png)

    Градиент помогает найти края объектов

    > Код примера: [cvmethods_gradient.py](./examples/cvmethods_gradient.py)

* Цветовая гистограмма

    Цветовая гистограмма показывает частоты значений пикселей красного, зеленого и синего (или других) каналов

    ![Гистограмма](./images/cvmethods_color_hist.png)

    Здесь на картинке большинство пикселей голубые, поэтому видим три большие пика, которые составляют голубой цвет

    К гистограмме можно применить эквализацию, что позволяет повысить контрастность изображения

    Эквализация работает так:

    1. На основе цветовой гистограммы строится кумулятивная функция $F(x)$, которая равна доли пикселей, значения которых не больше $x$, из всех

    2. Значение конечного пикселя вычисляется как $\mathrm{dst}(x, y) = \mathrm{round}((N - 1) \cdot F(\mathrm{src}(x, y)))$, где $N$ - максимальное допустимое значение для пикселя

    Это работает на черно-белой картинке, но не на цветной, так как оттенки меняются слишком сильно. Вместо этого изображение конвертируют в HSV и эквализацию применяют на канале со значением Value:

    ![Эквализация](./images/cvmethods_color_hist_equalization.png)

    > Код примера: [cvmethods_color_hist.py](./examples/cvmethods_color_hist.py)
